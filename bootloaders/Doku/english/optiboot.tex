\chapter{The optiboot boot-loader for AVR Micro-controllers}

\section*{}
The optiboot Boot-loader has been created with C language by Peter Knight and
Bill Westfield. I have used the version 6.2 as base
for the here described revised Assembler version.
I would like to underline, that I did not reinvent the
optiboot boot-loader. I have just done some optimizing.
Many adaptions to several target processors and special
board level systems are present with the version 6.2.
The program use parts of the STK500 communication protocol,
which is released with AVR061~\cite{stk500} from Atmel.


\section{Changes and enhancements to the version 6.2}
Basically I have translated the total program in the assembler language
and have adapted the Makefile, that the program length will
be processed automatically to select the start address of the boot-loader
and set the right fuses for the program length.
The selected solution generates some small files during some
interim steps, which are required to solve the following steps
to select the right start address and the right fuses.
The start address of the boot-loader for any target processor
depends on the present flash size, the flash requirement
of the boot-loader code and the tile size, which is supported
by the target processor for bootlace.
The tile size is the smallest boot-loader size, which can be supported
by the selected target processor.


For processors like the ATtiny84, which don't support the boot-loader start function,
the page size of the flash memory is used for this calculation.
For the ATtiny84 this are 64 Bytes. Therefore the start address of
the boot-loader is always located at the begin of a flash page.

For all other supported target processors the boot-loader area can be
selected with the fuse bits BOOTSZ1 and BOOTSZ0 (each with the values 0 and 1).
If you put together the both bits, you get a coded boot-loader size
with values between 0 and 3.
Always the value of 3 select the smallest possible boot-loader area.
A value of 2 select a double size, the value 1 the quadruple size
and the value 0 select a size of eight times the smallest size.
The table~\ref{tab:bootsz} at page~\pageref{tab:bootsz} shows a 
overview for the several target processors.

\section{Automatic size adaption in the optiboot Makefile}

The boot-loader start address and the required boot-loader size will
be adapted automatically with the Makefile.
For the calculation some interim files are created,
which is only possible together with some Linux tools:

\begin{description}
\item [bc] a simple calculator, which can operate with input and output-
values in decimal and hexadecimal values.
\item [cat] put the file content to the standard output.
\item [cut] can select part of lines of a text.
\item [echo] shows the specified text at standard output.
\item [grep] shows only lines of a text file which contain the specified string.
\item [tr] can replace or erase characters.
\end{description}

Until now this function of the Makefile is only tested with a Linux system.
Probably a use with the Windows system is only possible,
if you install the Cygwin package.

You don't handle the different interim files in normal case.
Here I would like to refer the names and the meaning:
\begin{description}
\item [BootPages.dat] hold the count of required pages by the boot-loader.
For processors which support the boot-loader start feature, the value can be only 1, 2, 4, or 8 and
specifies how many times the minimum size of the boot-loader area (tile) is used.
With the virtual boot-loader support the number can be any value and
specifies the count of required flash pages.
\item [BOOTSZ.dat] hold a number between 0 and 3 for selection of the  BOOTSZ0 and BOOTSZ1 bits.
\item [BL\_StartAdr.dat] hold the start address of the boot-loaders with hexadecimal format.
The start address is computed with the flash size of the selected target processor and
the count of required page or tile size.
\item [EFUSE.dat] hold the value for the efuse in hexadecimal format.
The Makefile determine depending of the target processor type,
if this file is used or not.
\item [HFUSE.dat] hold the value for the hfuse in hexadecimal format.
The Makefile determine depending of the target processor type,
if this file is used or not.
\end{description}

\section{target selection for the optiboot Makefile}

The control of steps for generating the program data from
the source code is defined in the Makefile.
Except the main Makefile there are three additional extension Makefiles,
which are included by the main Makefile:
Makefile.1284, Makefile.atmel, and Makefile.extras .
There can exist different configurations for the same processor type.
The table~\ref{tab:processors} shows different basic configuration
for several target processors.
In principle this list can be extended.
You can select some parameters also with the make call or by setting
a environment variable  of the shell.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
             Name  & MCU & AVR\_ & total & Flash & BP\_ & LFUSE & HFUSE & EFUSE  \\
                   &     & FREQ  & Flash & page  & LEN  &       &       &        \\
                   &     &       &  size & size  &      &       &       &        \\
    \hline
    \hline
         attiny84 & t84   & 16M? &  8K   &  64   & (64) &  62   &  DF   & FE \\
    \hline
         atmega8  & m8    & 16M  &  8K   &  64   & 256  &  BF   &  CC   &  - \\
    \hline
         atmega88 & m88   & 16M  &  8K   &  64   & 256  &  FF   &  DD   &  04 \\
    \hline
       atmega16   & m16   & 16M  &  16K  & 128   & 256  &  FF   &  9C   &  - \\
    \hline
       atmega168  &  m168  & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
       atmega168p &  m168p & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
    \hline
       atmega32   &  m32   & 16M  &  16K & 128   & 256  &  BF   &  CE   &  - \\
    \hline
       atmega328  &  m328  & 16M  &  32K & 128   & 512  &  FF   &  DE   &  05 \\
       atmega328p & m328p & 16M  &  32K  & 128   & 512  &  FF   &  DE   &  05 \\
    \hline
       atmega644p & m644p & 16M  &  64K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1284  & m1284  & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
     atmega1284p & m1284p & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1280  & m1280  & 16M  &  128K & 256   & 1K   &  FF   &  DE   &  05 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Processor targets for optiboot Makefile}
  \label{tab:processors}
\end{table}

All size values are shown in byte units, the values for fuses are shown with hexadecimal values.
The frequency values must be specified in Hz units, 16M is the same as 16000000 Hz.
The standard baud rate of the serial interface is always 115200.

Additional to the universal processor configurations you can also select
configurations for special boards or operational environment.
The table~\ref{tab:boards} shows the different adjustments.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
    \hline
             Name  & MCU & AVR\_ & BP\_ & L     & H     & E     & BAUD\_ & LED & SOFT\_ \\
                   &     & FREQ  & LEN  &  FUSE & FUSE  &  FUSE & RATE &     & UART \\
    \hline
    \hline
       luminet     & t84 &  1M   & 64v &  F7   &  DD   &  04   & 9600 & 0x  &  -   \\

    \hline
         virboot8  & m8    & 16M & 64v &       &       &       &      &     &      \\
    \hline
       diecimila  &  m168 & (16M) &     &  F7   &  DD   &  04   &      & 3x  &  -   \\
       lilypad    &  m168  & 8M  &      &  E2   &  DD   &  04   &  -   & 3x  &  -   \\
       pro8       &  m168  & 16M &      &  F7   &  C6   &  04   &  -   & 3x  &  -   \\
       pro16      &  m168  & 16M &      &  F7   &  DD   &  04   &  -   & 3x  &  -   \\
       pro20      &  m168  & 16M &      &  F7   &  DC   &  04   &  -   & 3x  &  -   \\
    atmega168p\_lp&  m168  & 16M &      &  FF   &  DD   &  04   &  -   &     &  -   \\
   xplained168pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
       virboot328  & m328p & 16M & 128v &       &       &       &      &     &  -   \\
    atmega328\_pro8& m328p & 8M  &      &  FF   &  DE   &  05   &  -   & 3x  &  -   \\
   xplained328pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
   xplained328p   &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
        wildfire  & m1284p & 16M &      &       &       &      &   -   & 3xB5 &      \\
    \hline
       mega1280    & m1280 & 16M &      &  FF   &  DE   &  05   &  -   &     &  -   \\
    \hline
    \end{tabular}
  \end{center}
  \caption{configured targets for the optiboot Makefile}
  \label{tab:boards}
\end{table}

\section{The Options for the optiboot Makefile}

With the options you can select the feature of the optiboot boot-loader.
For example you can select with the option SOFT\_UART, that a software solution
is used for the serial communication.
Without this option a integrated hardware UART is used for serial communication.
The pin TX (Transmit) is used for serial output and the pin RX (Receive) is used
for serial input. If more than one UART is present at the target processor,
the first interface with the number 0 is used.
But you can also select every other present UART by specify the number with
the option UART (UART=1 for the second present UART).
For the hardware UART interfaces the pins for transmit and receive are fixed
to the specific pins. For the serial communication with software you can
select any pins, which are able to do digital input and output.
More details for the available options you can find in the tables~\ref{tab:options1}
and \ref{tab:options2}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example         & Function                                            \\
   the Option         &                &                                                     \\
    \hline
    \hline
    F\_CPU         & F\_CPU=8000000 & Tell the program the clock frequency of the processor. \\
                   &                & The value is specified in Hz units (cycles per second). \\
                   &                & The example specifies a frequency of 8 MHz. \\
    \hline
    BAUD\_RATE     & BAUD\_         & Specifies the baud-rate for the serial communication. \\
                   &  RATE=9600     & Always 8 data bits without parity is used. \\
    \hline
    SOFT\_UART     & SOFT\_UART=1   & Select a software solution for the serial communication. \\
    \hline
    UART\_RX        & UART\_RX=D0   & Specifies the port and bit number used for the serial input. \\
                   &                & The example select bit 0 of PIND as serial input. \\
                   &                & You can use this option only with the software UART. \\
    \hline
    UART\_TX        & UART\_TX=D1   & Specifies the port and bit number used for the serial output. \\
                   &                & The example select bit 1 of PORTD as serial output. \\
                   &                & You can use this option only with the software UART. \\
    \hline
    UART           & UART=1         & Select a hardware UART used for the serial communication \\
                   &                & You can only select a UART if more than one is present. \\
    \hline
 LED\_START\_      & LED\_START\_   & Select a repetition count of flashing cycles for the \\
   FLASHES         &   FLASHES=3    & control LED. A count of 1 or -1 will only flash once \\
                   &                & without a loop. Negative values will force a \\
                   &                & additional check of the RX pin of the serial interface. \\
                   &                & The loop is interrupted immediately, if any incoming \\
                   &                & serial data is detected. Please note, that the start of \\
                   &                & application program is delayed with the blink cycles. \\

    \hline
 LED               & LED=B3         & Select a port and bit number for the control LED. \\
                   &                & The example would select the bit number 3 of the \\
                   &                & port B for the LED connection. With the option \\
                   &                & LED\_START\_FLASHES  this LED will flash the \\
                   &                & specified count before the communication start. \\
                   &                & With the option LED\_DATA\_FLASH the LED will glow \\
                   &                & during wait for serial input. \\
    \hline
 LED\_DATA\_       & LED\_DATA\_    & The control LED will glow during waiting for \\
      FLASH        &    FLASH=1     & serial input data. \\
    \hline
 TIMEOUT\_MS       & TIMEOUT\_MS=2000 & This option specifies a time limit in ms units \\
                   &                  & for receiving boot data. After this time without \\
                   &                  & data the boot process is aborted and the \\
                   &                  & processor tries to start the user program. \\
                   &                  & Possible values for TIMEOUT\_MS are 500, 1000, 2000, \\
                   &                  & 4000 and 8000. The efffective value can be limited \\
                   &                  & to 2s because of processor limits for the watchdog. \\
                   &                  & If no TIMEOUT\_MS is specified, the time limit is \\
                   &                  & set to 1 second. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Important options for the optiboot Makefile}
  \label{tab:options1}
\end{table}

When operating with the internal RC generator, it is quite possible that a serial data transfer
not immediately succeed. This is principle independent of whether the hardware UART interface
or a software solution (SOFT\_UART) is used.
Without additional measurement you can only try with estimated OSCCAL\_CORR values.
Probably the data sheet of the AVR processor can help a little bit.
Here is described at which operating voltage and at what temperature the RC oscillator
was calibrated. 
In addition here is also described the gradient of frequency change with operating voltage,
temperature and OSCCAL modification.

More options are listed in table~\ref{tab:options2} . 
Some of these options are only interesting for software checks and
for processors without the boot-loader support.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example        & Function                                            \\
   the Option     &                &                                                     \\
    \hline
    \hline
    SUPPORT\_      & SUPPORT\_      & Select the EEprom read and write function for the  \\
    EEPROM         &  EEPROM=1      & boot-loader. If the assembly language is selected as \\
                   &                & source, the EEprom support is enabled without  \\
                   &                & this option, but can be switched off by setting \\
                   &                & the SUPPORT\_EEPROM Option to 0. \\
                   &                & For the C-source the function must be switched \\
                   &                & on (default = off). \\
    \hline
 C\_SOURCE         & C\_SOURCE=1    & Select the C language as source instead of the  \\
                   &                & assembly language (option 0 = assembly).\\
                   &                & The assembly version requires less program space. \\
    \hline
 BIGBOOT           & BIGBOOT=512    & Select additional space usage for the compiled \\
                   &                & program. This is used only for tests of the \\
                   &                & automatic adaption to the program size. \\
    \hline
VIRTUAL\_          & VIRTUAL\_       & Changes the interrupt vector table of a user program, \\
 BOOT\_            & BOOT\_          & that the boot-loader is called with a Reset. \\
 PARTITION         & PARTITION       & For the start of the user program another \\
		   &                 & interrupt vector is used.          \\
    \hline
 save\_vect\_      & save\_vect\_    & Choose a interrupt vector number for the  \\
      num          &    num=4        & VIRTUAL\_BOOT\_PARTITION method.        \\
    \hline
 OSCCAL\_          & OSCCAL\_       & With the option OSCCAL\_CORR you can adjust the \\
 CORR              & CORR=5         & internal 8~MHz RC-generator of the AVR. \\
                   &                & Is effectless with crystal-operation or external clock! \\
                   &                & The correction value will be subtracted from the actual \\
                   &                & OSCCAL byte. The frequency will be lower with a positive \\
                   &                & correction value. Because the produced Baud rate is \\
                   &                & directly derived from the processor clock, a correct \\
                   &                & selected processor clock is important for a successful \\
                   &                & serial communication. The value must be between -15 and +15. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{More options for the optiboot Makefile}
  \label{tab:options2}
\end{table}

\section{Usage of optiboot without a boot-loader area}

For processors without a special boot-loader area in the flash memory, for example the ATtiny84,
a solution is selectable to use the optiboot anyway.
This function can be selected with the VIRTUAL\_BOOT\_PARTITION option.
To start the boot-loader first with every Reset of the processor, the interrupt
vector table of the application program is changed.
At the reset vector location a jump to the optiboot program is registered.
The original start address of the application program will be moved to
another interrupt vector the ''replacement reset vector''.
This interrupt vector should not be used by the application program.
If the boot-loader does not receive any data from the serial interface within
a appropriate time, the boot-loader jump to the location of the replacement
reset vector and start the application program.
The figure~\ref{fig:VectorMove} should illustrate these changes.

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/VectorMove.eps}
\caption{Changes of program data by optiboot}
\label{fig:VectorMove}
\end{figure}

At the left side the content of the program data file (.hex) is shown.
Just to the right the content of the flash memory is shown, as it is modified by the
optiboot boot-loader. At two interrupt vector addresses the content is changed.
At the reset vector address 0 the jump is modified to select the optiboot start address 
as jump target.
At the ''replacement vector address'' 4 the original jump target address of the application
program's reset vector is used as new jump target address of this vector.
One of the problems with this modification is, that usually the program data
is verified by the host after write is finished.
To provide any error message by verify the program data, the optiboot return the
program data without its own modification, not the real content of the interrupt vector table.
The jump target address of the reset vector can be reconstructed with the content
of the replacement vector address.
But the original content of the replacement vector would be lost because there is no
place to save the original content in the flash memory.
Therefore optiboot use the last two places of the EEprom memory to save this original
content of the replacement vector. 
So the verify of the program data is possible without errors, as long as the application
program do not use one of the last two EEprom locations.
Even if the application program use one of the last two EEprom locations,
the boot-loader will be unaffected. Only the program verify by the host is
no longer possible without a error message.
An error message will occur at the location of the replacement interrupt vector.

For processors with more than 8 kByte flash memory two instruction words are used for every
interrupt vector. Normally every of this double words hold one JMP instruction with the
proper jump target address. The optiboot program can respect these JMP vector table too.
But if you use the linker avr-ld with the option --relax, all JMP instructions are replaced
by a RJMP, if this is possible for the target address.
This replacement of JMP instruction in the vector table by RJMP is not respected
by the optiboot program.
The optiboot program assume, that all interrupt vector numbers of a processor with
more than 8 kByte flash hold a JMP instruction.
For that reason a optiboot program with the VIRTUAL\_BOOT\_Partition option will not
work with a application program, which is linked with the --relax option.
The same problem exist, if the application program itself use a RJMP instruction in
one of the two critical interrupt vector positions.

Further you should notice, that you don't activate the BOOTRST fuse together with
with the usage of the VIRTUAL\_BOOT\_PARTITION option.
The reason is, that the start address of the boot-loader can be located to other
addresses with the VIRTUAL\_BOOT\_PARTITION option than without this option.
With the VIRTUAL\_BOOT\_PARTITION the start address can be placed to every
begin of a flash page. For the normal boot-loader support of the AVR the
start address can only respect the single, double, quadruple or octuple size of
a minimum boot-loader size as shown in figure~\ref{fig:pages} at page~\pageref{fig:pages}.


\section{Capabilities of the serial interface with the applied software}

Das Programm f√ºr die Erzeugung und Verarbeitung der elektrischen Signale ist in AVR-Assembler geschrieben.
The way of operation is taked over from the Application Note AVR305 of the ATmel Corporation.
However here are some special features build in.
For example it is respected, that we can not use the special bit-instructions SBI, CBI and SBIC for
any port address. You can use this instructions only up to the address 31 (0x1f).
For some higher port addresses up to 63 (0x3f) you can use special input (IN) and output (OUT)
instructions. If the addresses of the port are higher than this value, you must use
the instructions LDS and STS to access this ports. This instructions need 2 processor clocks for
execution and use the double flash memory (2 words or 4 byte) of the other instructions.
The changed cycle number of one loop pass without any additional delay will be automatically
determined by the program. 
This number of cycles is then taken into account for the calculation of the delay loop,
to achieve a correct time for the transmission of a bit.
The diagrams~\ref{fig:getch_timing} and~\ref{fig:putch_timing} should be used to
explain the work of the C-proprocessor.

\begin{figure}[H]
\centering
\scalebox{0.9}{\includegraphics[]{../FIG/uart_getch_timing.eps}}
\caption{Possible variants of the getch function}
\label{fig:getch_timing}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[]{../FIG/uart_putch_timing.eps}
\caption{Possible variants of the putch function}
\label{fig:putch_timing}
\end{figure}

Both loops are generated so that one cycle with the same conditions of INVERS option and
address range of the used ports use the same tic count.
So both functions can use the same function for generating the necessary delay.

\subsection{Computing of the delay time}
For the read-in function getch() is the half baud time needed.
From the detection of the start bit a total time of 1.5 times of the baud-time is delayed
to read the first data bit.
Therefore the base loop is designed for the half duration of a bit transmission.
This base loop is called twice in a special way, so that exactly twice the time is get.
Should one clock have been lost by the building of half the time and subsequent doubling,
this clock is compensated by adding a additional NOP command, so that the total time
is exactly correct for the transmission of one bit.
Because of the limited time resolution of the counter loop of 3 tics, a remainder of up to 2 clock tics
is compensated by adding a additional instruction with the right tic count (RJMP or NOP).
Of course, all this happens automatically, because only the loop time of the input function (getch)
and the output function (putch), the clock frequency of the processor and the desired baud rate
must be known. All other parameters like the number of clocks for a subroutine call (RCALL, RET)
are known for the traget processor.
A disadvantage of the base delay loop is the limited number of clocks for the delay.
With the used 8-bit counter only a maximum of 256*3 clocks is possible for the loop delay.
In addition there is the subroutine call of 7 tics, resulting in a half delay time of 775 tics.
This value must be doubled (delay for a whole bit time) and the loop-time of the input or output
function must be added to get the total time possible. Thus the highest achievable delay time is 1559 clocks.
With a \(16 MHz\) clock frequency you can not get a baud rate of 9600 Baud \(104.17\mu s\), because
the limit is only \(97.4\mu s\).
If a 16-bit counter is used by the delay loop, you would get an even worse resolution of time
because one loop cycle would take more time.
In addition, the 16-bit loop probably need to use the carry bit. The 8-bit counter don't use the carry bit.
This problem is solved by gradually doubling the delay times by doubling the delay loop call.
The C-prepocessor checks, if the initial value of the loop counter would match the 8-bit limit (255) at the
selected clock frequency and the desired baud rate.
In this cace the calculation is repeated for a double call of the base delay loop.
If the resulting initial value for the counting loop is still too high, the double call is doubled again.
Currently this procedure is repeated up to a factor 64 of the base time with the 8-bit counter.
At a clock frequency of \(16 MHz\) or \(20 MHz\) it is now possible to set the serial interface to 300 baud.
For every doubling of the delay time, a additional instruction (2 bytes) is required.
With the maximum count of doubling 6 additional instructions (12 byte) are required in the flash memory.
There is no attempt to add additional instructions to compensate the missing tics caused by
the prescaler for saving flash memory.
The baud time error remains clearly below \(1\%\), because the scaler is used only if necessary.
So the base loop has at least 127 passes with approximately 381 tics, The double delay time
makes no error because of the ''NOP'' compensation. Thus the error stays below 1:762 \(0.13\%\). 
The higher baud rates tend to get higher error for the transmission time, because
the time frame of the CPU clock does not match to the desired baud time.
The hardware UART has then the same problem, if it use the same CPU-clock.
If you wish to generate a baud rate of 230400 with a CPU clock rate of \(8 MHz\),
you can use either 34 tics with a baud time of \(4.25\mu s\) or
35 tics with a baud time of \(4.375\mu s\).
For the first case your baud time is \(2.08\%\) too short, for the
second case the baud time is \(0.8\%\) too long.

\subsection{Using more than one serial interface}

The assembler file soft\_uart.S is designed to be included by a different file which hold
a normal assembler source for the AVR family.
For the optiboot application this is done by the optiboot.S file.
The included file soft\_uart.S use many instructions of the
GNU C-preprocessor and includes another file uart\_delay.S for producing a delay loop
for the desired baud rate. Because this include can be repeated with other parameters,
you can produce up to 4 different delay loops for 4 different baud rates.
This feature use the file soft\_uart.S for generatung a getch and a putch function.
For both functions the file uart\_delay.S is included. But for the second call is
usually no new code generated because the calling parameters are the same.
Only if the parameters differ, a new delay loop would be generated.
Please note, that the callings for the delay loop are named with C-preprocessor macros.
This macros are set to a matching delay loop named DOUBLE\_DELAY\_CALL and SINGLE\_DELAY\_CALL,
if you include the uart\_delay.S file before the code of the serial input or output function.

Three constants must be set before any include of uart\_delay.S, named F\_CPU, BAUD\_RATE and 
LOOP\_TICS. The LOOP\_TICS must be set to the count of tics of the serial input or output
loop for one cycle without any additional delay (usually 9 tics).
For every generated delay loop, the total count of delay tics are saved in one of four
different constant names of the C-preprocessor BIT\_CLOCKS\_0, BIT\_CLOCKS\_1,
BIT\_CLOCKS\_2 and BIT\_CLOCKS\_3 . 
Before a new delay loop is generated, the C-preprocessor checks, if any of the already
generated code for a delay match the new requirement.
Because also the file soft\_uart.S must be included to generate the code for the 
serial input and serial output function, you can repeat this include for another
serial interface. But you must set a additional constant for differing the name
in the functions.
If you set the SOFT\_UART\_NUMBER to 1 (\#define SOFT\_UART\_NUMBER 1) before the \#include,
the serial input function is named getch\_1 and the serial output function
is named putch\_1. If you define a constant named NO\_SOFT\_UART\_TX before the
\#include of soft\_uart.S, no serial output function is generated by this include.
The same is done with the serial input function, if you specify the constant NO\_SOFT\_UART\_RX.

\subsection{Serial Input and Output with only one AVR Pin}

Sometimes it makes sense to operate the serial communication only with one pin,
to unlock one of the few IO pins of small AVRs for other use.
With a special circuit technology can be achieved that you can read in data in the
output pauses. The software solution of optiboot can only use the half-duplex operation
in any case.
Thus, at one time, only either data can be send or data can be received.
Normally the output pin with the TX function becomes high in the transmission pauses,
which prevent a data reading on the same pin.
But if the TX output pin is switched to input mode instead of the high level,
a external pull-up resistor can provide the required high level.
In contrast to the fixed high level now a externally connected TX signal
can pull down the level and let the input function read the low level.
A serial resistor in the connection between the common TX/RX pin of the AVR
with the external TX output can serve as pull-up resistor,
because the idle state if the interface is a high signal.
In addition, this serial resistor provides current limiting,
if both TX interfaces send at the same time.
The external RX interface must be connected directly to the common TX/RX pin
to enable the reading of the external RX interface.
The figure~\ref{fig:onewire-simple} should illustrate this simplest connection.

\begin{figure}[H]
\centering
\scalebox{1.0}{\includegraphics[]{../FIG/OneWire_simple.eps}}
\caption{Possible serialconnection to a AVR with one Pin}
\label{fig:onewire-simple}
\end{figure}

Now is the problem, that the mostly full-duplex capable external interface will
read back the own output.
The communication program at the external side is usually unprepared for this condition.
One solution for this problem is to adapt the program at the external side to handle
this read back.
But I believe, that this is not a good idea, because this special version will 
have no maintenance or you must repeat this adaption for new versions constantly.
That's why I prefere a hardware solution.
A electronic circuit between the both endpoints must differ, from which side
the data are send.
A corresponding circuit suggestion is shown in figure~\ref{fig:onewire}

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire.eps}}
\caption{Circuit for suppressing the echoes}
\label{fig:onewire}
\end{figure}

With the first two NAND gates of the HCF4093 a flip-flop is build,
which is set or reset by the two other NAND gates of this chip.
The switching signals are get from from signals of a chain of inverting buffers
with Schmitt-trigger inputs (HC7414).
For one of this signals a additional C-R circuit (\(120 pF\) and \(3.3 k\Omega\) is
required to prevent switching at the wrong edge.
The flip-flop is switched with the 1-0 edge of the two transmission sides.
This changeover is only required at the edge of the start bit.
But additional switching with data bits will not hurt, if the flip-flop
is already in the right state.
When the external interface sends, the reception of the own data with the
external receiver is prevented. The external RX signal remains at high level.
With this additional circuit no software adaption is necessary.
You can use avrdude for example for the bootloader.
The circuit is largely independent of the selected baud rate.
I expect only problems with very high baud rates.
At 115200 baud the circuit operates well. Much higher baud rates can 
not be used in most cases with the software serial interface.

\subsection{Use of the automatic baud rate detection}

If you specify a baud rate below \(100Baud\) for generating the bootloader code,
the program will be prepared to detect the baud rate from the first
received character.
At the begin if the transmission with the STK500 protocol the computer send
a command STK\_GET\_SYNC (0x30) followed by the control character CRC\_EOP (0x20).
For the serial transmission protocol the High level (1) is defined as the idle state.
The begin of a transmission is started by s start bit with Low level (0).
Directly after the end of the start bit the first data bit is send 
beginning with the low order bit. After the last of the aggreed count of bits (8)
is transmitted, the transmission is finished with one or more Stop bits at High level (1).
The level of every bit is hold exactly the aggreed baud time.
The time between the end of the last Stop bit and the begin of the next Start bit
is unspecified.
The figure~\ref{fig:AutoBaud} shows the expected results for all possible
time measurement. At the time axis ''t'' four possible start positions
are marked for a complete time measurement of the assumed character.
The counter is started in each case of a detected 1-0 slope.
The right start position for the STK\_GET\_SYNC character is marked with ''1''.
The marks ''2'', ''3'' and ''4'' show the situation for three possible
wrong Start bit detections.
For the mark ''2'' and ''4'' a 1-0 slope of data bits is detected as Start bit
in a wrong way. For the mark '3' is a Start bit correctly detected, but for the
wrong character (CRC\_EOP).
The wrong detections are allways possible, if the bootloader is started not
before the transmission was running.
The expected counter values are marked at the counter level graph for all
four start positions in figure~\ref{fig:AutoBaud}. 
The ''b'' means the counter reading for one bit transmission time (baud time),
the ''d'' stand for a possible time delay between the end of the Stop bit transfer 
and the start of a new Start bit.
The ''D'' represents a expected long time delay to the begin of the next message.
The transmit sequence of the message has reached it's end and the computer
wait for an answer of the AVR.
In the ''Rx''-row the data bits are labled with ''0'' (least significant bit)
to ''7'' (highest significant bit). The Start bit has the label 'A' and
a Stop bit has the label 'E'.
The first byte is the coding of the STK\_GET\_SYNC character and the second byte
is the coding of the control character CRC\_EOP.


\begin{figure}[H]
\centering
\scalebox{0.55}{\includegraphics[]{../FIG/AutoBaud.eps}}
\caption{Possibel timer measurements for the STK\_GET\_SYNC sequence}
\label{fig:AutoBaud}
\end{figure}

\begin{itemize}

\item {Simplest way of baud rate measurement, BAUD\_RATE \textless~50}

The simplest form of baud rate measurement doesn't take into account
the wrong start bit choise.
It is assumed, that the detected Start bit belongs to the STK\_GET\_SYNC
character.
After the Start bit detection the program waits to the next 0-1 slope
and starts a 16-bit counter with the frequency F\_CPU/8 with the
stating value -1. At the next 1-0 slope the counter value is read out
and the half of this value is taken as frequency divider for the UART.
The building of the half value is required because the time of two data bits
was measured.
Normally 1 must be subtracted for the UART frequency divider.
But when halving should be rounded, a 1 must be added before the halving.
Because also 2 can be subtracted from the counter result instead of
1 from the division result, totally only one must be subtracted from the
counter result. In order to save computation steps, the subtraction (2-1=1)
from the count is done by a start value of the counter of -1.

This mmothod works well, if the bootloader is started automatically just
before the transmission by generating a reset pulse from the DTR (Data Terminal Ready)
signal of the serial interface.
You can also be successfull without the automatically generated Reset,
if a Reset key is connected to the AVR, which should be hold pressed
until the transmission program is started.
But this procedure requires some feeling for the right release time
of the button.

The bootloader only waits a maximum time for the beginning of the transmission,
which is specified from the watchdog timer.
When the watchdog timer triggers a reset, usually the user program is started.
Only if no user program has been loaded yet, the boot loader starts again for a retry.

\item {Slightly improved way of baud rate measurement, BAUD\_RATE \textless~60}

The same method as the simplest way is used for this method.
Only a additional limitation for the timer value is used here.
If the time limit is passed over, the program starts again with the search
for a new Start bit.
Without this limitation the program can stay in a loop for detecting
a low level for the start condition ''4''. 
Probably the bad situation with the start position ''4'' in the 
diagram~\ref{fig:AutoBaud} is a little better. 
The restart of the start bit serach with the time limit would
delay a reset from the watchdog timer only a little bit.
The bootloader program may not reset the watchdog timer inside
the search loop, because then the user program is never started
without the transmission of a new program.
For this reason the time limit of the watchdog timer must be greater
as the time delay for repeating the STK\_GET\_SYNC sequence
without a answer to the previous STK\_GET\_SYNC sequence.


\item {Complex way of baud rate measurement, BAUD\_RATE \textless~80}

With this method the counter is started immediately with the detection
of a Start bit and the counter value is read with every of the
next 3 bit changes.
The time sequence of bit changes for the STK\_GET\_SYNC character is 
measured with this method, if the start position is well (''1'').
With this measured time sequence some plausibility checks are done.
For a first is checked, that the difference between the third counter
reading and the first counter reading is less than the value
of the first reading.
For the start position ''1'' this is the case ((9b~-~5b) < 5b).
For the wrong start position ''3'' this is unfortunately also the case ((9b~-~6b) < 6b)
But this test will fail for start condition ''2'', if the time delay ''d'' of
the second start bit of the STK\_GET\_SYNC sequence is sufficiently small.
For the wrong start position ''4'' can help only a time limitation for
the second bit change wait loop, because the repetition of the STK\_GET\_SYNC
is done after a longer wait time for the answer (''D''). 

A second test checks, if the difference between the third and the
second counter reading isn't significant greater than the difference
between the second and the first counter reading.
For the correct start posistion ''1'' this result to the equation ((9b-7b) < (7b-5b+4))
or (2b < 2b+4).
For the false start position ''2'' you get the equation ((9b-3b) < (3b+d-2b+4)) or
(6b < (b+d+4)).
For the false start position ''3'' we get the equation ((9b-7b) < (7b-6b+4)) or (2b < (b+4)).
This exams are relatively safe for detecting the right baud rate, but they
require a lot of additional space for the program.
This method is especially recommended, if at least 1024 bytes are reserved
for the boot loader anyway (boot loader page size).
For setting the correct UART frequency divider, the difference between 
the third counter reading and the second counter reading is divided by 2
(9b-7b-1)/2 = (2b+1)/2-1.

\item {Aufwendige Form der Baudraten Messung, BAUD\_RATE \textless~100}

All counter readings and checks are done in the same way as the
BAUD\_RATE \textless~80 method. Only the calculation of
the UART divider is based on the time of four bits instead of two bits.
Consequently the equation for the correct starting position
look like (9b-5b-2)/4 = (4b+2//4-1.

\end{itemize}

I recommend for all methods of the baud rate determination to omit
the LED flashing at the begin of the bootloader program
to prevent a delay of the start bit detection.
Unfortunately even the simplest way of baud rate measurement
need so much additional program memory, that the bootloader
will not fit into the 512 byte limit, if the EEprom support
is selected (SUPPORT\_EEPROM=1) with the flashing LED function.
For some processors you can select the additional function LED\_DATA\_FLASH
without exceeding the 512 byte limit, when the EEprom support is deselected.
If the 512 byte limit is overshoot by a required function,
the next limit of 1024 byte give enough space for all additional
selections.
You can select the SOFT\_UART function together with the automatic
baud rate detection (BAUD\_RATE \textless 100) only for the
assembler version of optiboot, not for the C-version.

There are some differencies and special features for the baud rate measuring
together with the Soft UART solution compared to the hardware UART solution.
Usually a 8-Bit counter loop is used to generate the delay for the half baud time.
Because of the used instructions in this loop, you can select the time
only with a solution of 3 clock tics.
To get the full baud time the loop must be called twice, so that
the resolution is doubled too.
With a known fixed baud rate this error will be compensated by extra instructions.
But this is impossible, if the baud rate  is unknown in advance.
To get the best possible rounding of the selected baud rate,
the time measurement is done with the 16-bit counter at the full CPU clock rate (F\_CPU).
For the hardware UART the counter can be used with F\_CPU/8.

The use of a 8-bit delay loop result to a upper limit of the baud time
depending on the CPU clock rate.
The resulting minumum baud rate is definite higher with the 8-bit loop
compared to the minimum baud rate with the hardware UART.
With the limited resolution of the period selection for the baud rate
the upper limit can be specified with a guaranteed baud rate error below 2\%.
If the AVR processor is operated with a RC clock generator, the clock rate
is usually imprecise. By measuring the baud rate with a counter controlled
with the same clock, this error is compensated.
But the error by reason of the limited resolution of the baud rate divider 
can not be calculated in advance.
I would like to show you what I mean by an example for the hardware UART. 
The baud rate \(250kHz\) can be used with a clockrate of exactly \(8MHz\).
If you select the divider of 4, the desired baud rate is together with
the factor 8 prescaler produced without a deviation.
If I assume a inexact real clock rate of \(7.6MHz\),
the best selectable divider is still 4.
For this case the actual baud rate is now \(237.5kHz\) with the same
error of -5\% as the base clock rate.
To overcome at least the lower baud limit with the software UART solution,
all odd baud rate selections below 100 will generate a code
with a 15-bit delay loop.
Unfortunately the pass time of this loop is 5 tics for the 15-bit loop.
Because of the double delay call for the full baud time,
the resolution is only 10 tics and thereby more worth than the 
8 tics resolution of the hardware UART caused by the 8:1 prescaler.
You should use this option only, if you need the support of low baud speeds
and deside not to use very high baud rates.
The following table~\ref{tab:AutoBaud8} is intended to clarify the use of
the different auto baud functions at the operating frequency \(8MHz\).

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
   BAUD\_RATE  & SOFT\_ & Minimum & BAUD-Err & Comment  \\
   Option      & UART   & Baud    & \textless 2\% @ Baud &  \\
    \hline
    \hline
    40-99      &  0     &  1949       &   40.0k  & HW\_UART  \\
    \hline
    48         &  1     &  5151       &   46.2k  & Simple, 2-Bit Time, 8-Bit Delay  \\
    \hline
    68         &  1     &  5151       &   46.2k  & Complex, 2-Bit Time, 8-Bit Delay  \\
    \hline
    88         &  1     &  5151       &   46.2k  & Complex, 4-Bit Time, 8-Bit Delay  \\
    \hline
    49         &  1     &  244       &   29.0k  &  Simple, 2-Bit Time, 15-Bit Delay\\
    \hline
    69         &  1     &  1220       &   29.0k &  Complex, 2-Bit Time, 15-Bit Delay \\
    \hline
    89         &  1     &  1220       &   29.0k & Complex, 4-Bit Time, 15-Bit Delay \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Limits for the automatic baud rate selection with a \(8MHz\) clock.}
  \label{tab:AutoBaud8}
\end{table}

If you select a hardware UART interface, you can select the standard
baud rates 2400, 4800, 9600, 19200 and 38400 with all arbitrary options.
Higher baud rates than the specified 40 kBaud are not safe to use,
although 57600 baud also worked well in tests.
Likewise, a test with 115.2 kBaud at \(16MHz\) crystal operation was still successful
when using a software UART with a 15-bit delay loop.
If only a 8-bit delay loop is used with the software UART solution,
the baud rates 2400 and 4800 can not be used.
The lower baud rates are only usable, if you configure the optiboot
with a 15-bit delay loop.
The different limit for the 49 and 69 or 89 baud rate selection is caused
by the different use of the 16-bit AVR counter.
With the 49 selection (all below 60) only the time of two data bits is measured
with the counter. For selections above 59 the complete byte sequence is
measured from the Start bit to the Stop bit with the 16-bit counter.
Probably baud rated below 9600 are rarely used anyway.
Of course the limits of the baud rates change with other processor clock rate.

Finally I would like to show the results from tests, which I have done with
a ATmega1281 with the internal \(8MHz\) RC-generator clock at a specified baud rate
and also above the specified baud rate.
The frequency was tuned with the OSCCAL\_CORR option in steps of two and
of course measured.
The functionality was tested by loading a small user program.
All tests within the specified baud rate was successfull.
Because all tests run well, additionally tests with a higher baud rate than
specified (\(115.2 kBaud\)) was also done.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c || c | c | c || c | c |}
    \hline
   OSCCAL  & Frequency & HW-UART & SW-UART & SW-UART & SW-UART & SW-UART \\
   \_CORR  & kHz       & 57600   & 57600   & 57600   & 115200  & 115200  \\
           &           & Mode 82 & Mode 82 & Mode 83 & Mode 52 & Mode 53 \\
    \hline
    \hline
    20     &  7157   &  OK (Err)  &   OK     &   OK    &  Err    &   Err \\
    18     &  7217   &  OK (Err)  &   OK     &   OK    &  Err    &   Err \\
    \hline
    16     &  7318   &  OK (OK)   &   OK     &   OK    &  OK     &   Err \\
    14     &  7404   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    \hline
    12     &  7521   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    10     &  7591   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    \hline
     8     &  7710   &  OK (Err)  &   OK     &   OK    &  OK     &   OK  \\
     6     &  7815   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    \hline
     4     &  7933   &  OK (OK)   &   OK     &   OK    &  Err    &   Err \\
     2     &  8012   &  OK (OK)   &   OK     &   OK    &  OK     &   Err \\
    \hline
     0     &  8141   &  OK (Err)  &   OK     &   OK    &  OK     &   Err \\
    -2     &  8247   &  OK (OK)   &   OK     &   OK    &  OK     &   Err \\
    \hline
    -4     &  8390   &  OK (OK)   &   OK     &   OK    &  OK     &   Err \\
    -6     &  8485   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    \hline
    -8     &  8623   &  OK (OK)   &   OK     &   OK    &  Err    &   OK  \\
    -10    &  8745   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    -12    &  8889   &  OK (OK)   &   OK     &   OK    &  OK     &   OK  \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Test for the automatic baud rate at \(8MHz\) clock.}
  \label{tab:AutoBaudTest8}
\end{table}

The bracketed values in the HardWare UART column appear only, if a second Stop bit
is selected with the UCBS1 bit in the UCSR1C register.
This problem is incomprehensible because, as described in the datasheet, this bit
should only affect the transmitter.
For the receiver of the data, a second stop bit means only a longer wait time to the next start bit.
This should be no reason for difficulties. Only the transmission time is a little bit longer.
The significant increase in errors allows only the conclusion that either the timing
of the receiver changes also by setting the USBS1 bit or the used USB-serial converter
can not handle this setting correctly.

For the operating mode 82 I have additionally checked the odd OSCCAL\_CORR settings without
any noticeable difficulties. The also checked simplest mode 42 has not shown
any difficulties with the tested even OSCCAL\_CORR values of the table.

Only at the extemely high baud rate of \(115,2k\) for this CPU frequency the operation
mode 52 shows four failures and with the operation mode 53 eight failures are stated.
The increase in failures in mode 53 with the 15-bit delay loop is expected and caused by
the coarser grid of adjustable delay times.
In another test series with the hardware UART at \(115.2kBaud\), which is not included
to the table, I could find five set frequencies where program loading was inpossible.

A test with a chinese Arduino UNO board, which use a CH340G chip as USB-serial converter,
could operate only up to \(38.4kBaud\) correctly.
With higher baud rates the read back of the flash data caused problems.
Probably the last byte of a package is sometimes not transmitted to the host and
the communication blocks.
The same test with a other Arduino UNO board, which use a Mega16U2 controller
for USB-serial conversion, didn't show the same problem.
This board could run with \(115.2kBaud\) and also with \(230.4kBaud\). 
Probably the reason is, that both processors (ATmega328p and Mega16U2)
use a real baud rate of \(250kBaud\).


\section{Some examples of building a optiboot bootloader}

The first example is the building of a bootloader for the popular ATmega328P:

\begin{verbatim}
optiboot $ make atmega328p
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
In file included from optiboot.S:612:0:
init_uart_fix_baud.S:31:8: warning: #warning "BAUD_RATE error greater than 2%" [-Wcpp]
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Error=2.12%
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    476	      0	      0	    476	    1dc	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
   -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}


With no additional option a baudrate of 115200 with a clock frequency of \(16 MHz\) is selected.
For serial output the hardware interface is selected.
You should notice, that the systematic baud rate error is above 2\% with the hardware UART.
The second example with the same processor is done with a software solution for the serial interface.

\begin{verbatim}
optiboot $ make atmega328p SOFT_UART=1
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=01 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
pin_defs.h:206:6: warning: #warning "SOFT_UART use Pin D0 as RX" [-Wcpp]
pin_defs.h:216:6: warning: #warning "SOFT_UART use Pin D1 as TX" [-Wcpp]
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  SoftUART_Real: 115107, Delay: 116*1, Error=-.07%
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    496	      0	      0	    496	    1f0	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
   -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Please note, that the software solution for the serial interface requires a little more flash memory,
but take use of only 1 boot page too. The systematic baud rate error is much smaller than the error with the hardware UART.
But the hardware UART has the advantage, that the input and output could be done simultaneous and is more tolerant against
short disturbance of the input signal.
For the software serial interface you can specify every digital IO-pin for input (UART\_RX) and output (UART\_TX). 
In this example the feature is used to automatically select the RX and TX of the hardware UART.
Please ignore the three warning messages, which tell you about the automatic selection.
The automatic IO-pin selection depends on the selected processor type and the selected UART number, if more than
one UART is available.


The last examples shows a configuration with the new automatic selection of the baud rate
by measuring the rate of the first incoming data.
The flashing of the LED at the program start is deselected in the first example to save flash memory.

\begin{verbatim}
optiboot $ make atmega328p LED_START_FLASHES=0 BAUD_RATE=52
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=52 -DLED_START_FLASHES=0 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
--------------------------------------------------------------------------------
Simple Baudrate measurement with time limit implemented in optiboot!
UART Minimum 3898 Baud, Error surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Auto-Baudrate configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    494	      0	      0	    494	    1ee	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}


for the last example the most complex methode of baud rate measurement
was selected because the limit of 512 byte would be exceeded with
selecting the LED flashing and the simplest measurement method (534 byte).

\begin{verbatim}
optiboot $ make atmega328p BAUD_RATE=82
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=82 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
--------------------------------------------------------------------------------
Complex Baudrate measurement implemented in optiboot! (4-bit)
UART Minimum 3898 Baud, Error surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7C00 = 31744
###########################################

16000000 Hz operation with Auto-Baudrate configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    596	      0	      0	    596	    254	optiboot.elf
Requires 2 Boot Pages, 512 Bytes each
BOOTSZ=2
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}


\section{Clock Frequency Correction of the internal RC-Generator}

The use of the serial interface is only possible, if the selected baudrate is
matched by both interfaces with only two percent deviation.
The actual baudrate is given by the processor clock and the selected scaling factor for
the serial IO-clock. 
The hardware UART interface scaled the processor clock with factor 8 or 16 and a
additional selectable divider between 1:1 and 1:4096 for generating the clock
for the serial IO.
For lower baudrates additional dividers with power of 2 can be additional selected.
If the relationship between the processor clock and the baudrate clock is
sufficiently high, the desired baudrate can be selected with low deviation.
By generating the optiboot bootloader code the systematic error is shown
at the terminal protocol.
Usually errors lower than 2\% are uncritical.
The implemented coding of the serial interface with software (SOFT\_UART) produce
lower systematic errors as the hardware UART.
The problems with the software solution of the serial interface is caused with
no filter for input data and the missing feature to organize the interface
full duplex. From the output of the last bit to the ability to receive
the next data is allways a little time delay.
For this reason you can expect fewer difficulties with lower baudrates for
the software UART.
All this considerations assume however, that the processor clock itself is
selected with sufficient accuracy.
With a crystal or ceramic resonator the clock frequency is usually accurate enough
without special activities. But for the internal RC-generator of the AVR processors
the situation is different.
The actual processor clock can differ too much from the desired value.
The processors are precalibrated at factory. But this calibration is
valid only for one temperature and operating voltage.
The sensivity of frequency changes with temperature and operating voltage
differ for the different processor types.
To enable a correction for the user of the processor, the calibration value
of the clock frequency is copied to a special IO register with the name OSCCAL
at every start of the processor.
The Optiboot bootloader can use the option OSCCAL\_CORR to correct a
known residual error of the clock frequency.
In the following subsections I have analysed the correction of the
RC clock frequency for some AVR examples.


\subsection{RC-generators check of the ATmega8}

The Atmega8 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In the table~\ref{tab:mega8freq} I have analysed all 4 selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -8  & 1050k &  4  & 983k  & 0  & 1004k \\
    \hline
                2M & 0xA2  & 19.2k &  -8  & 2098k &  4  & 1967k & 0  & 2008k \\
    \hline
                4M & 0xA3  & 19.2k &  -2  & 4201k & 10  & 3927k & 7  & 3999k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8231k & 13  & 7723k & 6  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8}
  \label{tab:mega8freq}
\end{table}

The table~\ref{tab:mega8freq} shows, that for the \(1Mhz\) and \(2MHz\) operation a correction of the
OSCCAL register is not required. This ATmega8 is calibrated for these frequencies
very good at the factory.
For the \(4MHz\) clock frequency a operation without correction is still possible,
but the correct clock frequency is better approximated with a OSCCAL\_CORR value of 7.
For the \(8MHz\) clock frequency the serial interface was still possible
withou the correction, but the serial interface runs more safely with
the OSCCAL\_CORR value 6.

\subsection{RC-Generators check of the ATmega8535}

The ATmega8535 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8535freq} shows the results for one example for
all 4 frequencies.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  3  & 982k  & 0  & 1001k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2095k &  4  & 1965k & 1  & 1998k \\
    \hline
                4M & 0xA3  & 19.2k &  -5  & 4204k &  8  & 3932k & 4  & 4012k \\
    \hline
                8M & 0xA4  & 19.2k &  -7  & 8420k &  6  & 7901k & 3  & 8003k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8535}
  \label{tab:mega8535freq}
\end{table}

\subsection{RC-Generators check of the ATmega8515 and the ATmega162}

The ATmega8515 can select 4 different frequencies for the internal RC generator
with the Low fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8515freq} shows the results of one exemplar 
for all 4 frequency selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  2  & 985k  & -1  & 997k \\
    \hline
                2M & 0xA2  & 19.2k &  -10  & 2099k &  3  & 1963k & -1  & 1999k \\
    \hline
                4M & 0xA3  & 38.4k &  -3  & 4192k &  10  & 3928k & 7  & 3979k \\
    \hline
                8M & 0xA4  & 38.4k &  -3  & 8396k &  10  & 7860k & 7  & 7966k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8515}
  \label{tab:mega8515freq}
\end{table}

The ATmega162 with a simular pin layout can only operate with the
\(8MHz\) RC generator frequency.
Table~\ref{tab:mega162freq} shows the result of one exemplar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                8M & 0xE2  & 38.4k &  0  & 8190k &   6  & 7718k & 2  & 8000k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-oscillator of the ATmega162}
  \label{tab:mega162freq}
\end{table}


\subsection{RC-Generators check of the ATmega328 family}

For the ATmega328 family only a RC oscillator frequency of \(8MHz\) can be selected.
This Frequency can be divided by factor 8 with a fuse-bit, so that a
operation with \(1MHz\) can be also selected.
The table~\ref{tab:mega328freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega48P &          8M & 0xE2  & 57.6k &  -6  & 8230k &  8  & 7720k  & 0  & 8010k \\
    \hline
mega88 &          8M & 0xE2  & 57.6k &  -2  & 8250k & 10  & 7770k  & 4  & 7990k \\
    \hline
mega168 &          8M & 0xE2  & 57.6k &  -5  & 8263k &  8  & 7720k  & 1  & 7970k \\
    \hline
mega328P &          8M & 0xE2  & 57.6k &  -5  & 8250k &  9  & 7723k  & 1  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega328 family}
  \label{tab:mega328freq}
\end{table}

For all checked processors the serial interface can be used with the internal
RC generator without any OSCCAL correction.
Only for the checked ATmega88 a correction would be worthwhile (OSCCAL\_CORR=4).

\subsection{RC-Generators check of the ATmega32 / 16}

You can select 4 different frequencies with the internal RC-generator for
the ATmega32 and the ATmega16, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The tables~\ref{tab:mega32freq} and \ref{tab:mega16freq} shows the results
with one test exemplar each.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c || c | c || c | c || c | c |}
    \hline
        &     AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
 Typ    &     FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
m32  &       1M    & 0xA1  &  9.6k &  -13  & 1049k & -1  & 980k  & -5  & 1001k \\
m32a &             &       &       &  -7  & 1046k &  4  & 984k  & 1  & 998k \\
    \hline
m32  &       2M    & 0xA2  & 19.2k &  -12  & 2102k &  0  & 1968k & -3  & 1997k \\
m32a &             &       &       &  -7  & 2105k &  6  & 1966k & 2  & 2005k \\
    \hline
m32  &       4M    & 0xA3  & 19.2k &  -5  & 4169k & 6  & 3942k & 3  & 3993k \\
m32a &             &       &       &   2  & 4192k & 14  & 3939k & 10  & 4015k \\
    \hline
m32  &       8M    & 0xA4  & 19.2k &  -7  & 8425k &  6  & 7888k & 3  & 7983k \\
m32a &             &       &       &   2  & 8408k & 14  & 7921k & 11  & 8014k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega32}
  \label{tab:mega32freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -11  & 1047k &  1  & 982k  & -2  & 998k \\
    \hline
                2M & 0xA2  & 19.2k &  -12  & 2099k &  0  & 1971k & -3 & 1995k \\
    \hline
                4M & 0xA3  & 19.2k &  -9  & 4291k &  3  & 3932k & 0  & 4002k \\
    \hline
                8M & 0xA4  & 19.2k &  -11 & 8415k & 2  & 7857k & -2  & 8013k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega16}
  \label{tab:mega16freq}
\end{table}

Whenever positive values appear in the MinCorr column or negative values in the MaxCorr
column, it is impossible to use the serial interface with this processor at this frequency 
without a frequency correction.
If a 0 appear in any of the Corr columns, the operation of the serial interface
is just possible.

\subsection{RC-Generator check of the ATmega163L}

The ATmega163L has only one \(1MHz\) RC-generator, which can be adjusted
with the OSCCAL register.
My exemplar had no preselection of the OSCCAL value.
Therefore, exceptiionally high correction values are required to select
a clock frequency of about \(1MHz\).

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0x92  &  9.6k &  -88  & 1026k &  -62  & 964k  & -77  &  998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequency of the ATmega163L}
  \label{tab:mega163freq}
\end{table}

\subsection{RC-Generator check of the ATmega64 / 128}

The ATmega64 and the ATmega128 can select 4 different frequencies for the
internal RC-generator with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In then tables~\ref{tab:mega64freq} and \ref{tab:mega128freq} all 4 frequencies
are checked.
At this point it should also be noticed, that the program data is loaded via the ISP
interface not with the signals MISO and MOSI but via the signals TXD (PE1) and
RXD (PE0). Of course this must be taken into account when connecting the
processor to the programmer.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -4  & 1024k &  6  & 975k  & 1  & 1000k \\
    \hline
                2M & 0xA2  & 19.2k &  -4  & 2047k &  6  & 1952k & 0  & 2015k \\
    \hline
                4M & 0xA3  & 19.2k &   4  & 4070k & 10  & 3939k & 8  & 3976k \\
    \hline
                8M & 0xA4  & 57.6k &   6  & 8028k & 10  & 7847k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega64}
  \label{tab:mega64freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -9  & 1051k &  3  & 985k  & 0  &  999k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2102k &  3  & 1971k & 0  & 2000k \\
    \hline
                4M & 0xA3  & 19.2k &  -3  & 4209k &  9  & 3960k & 6  & 4006k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8225k & 13  & 7723k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega128}
  \label{tab:mega128freq}
\end{table}

You can see at the tables, that there is no correction of the OSCCAL register necessary 
at \(1MHz\) and \(2MHz\) operation for using the serial interface.
For operation at \(4MHz\) or \(8MHz\) the checked ATmega64 can not use
the serial interface without a frequency correction.
The \(4MHz\) frequency is about 4\% too high Without the correction and
the \(8MHz\) frequency is about 4.3\% too high.
You can find a hint in the Atmel documentation, that the RC-generator of the
ATmega64 and ATmega128 is calibrated at \(1MHz\).
It should be noted once again, that the the tabular data is the test result of a single copy
of the ATmega. Outside the specified minimum or maximum values of the OSCCAL-corrections,
it was not possible to operate the serial interface at thespecified baud rate.

\subsection{RC-Generator check of the ATmega644 family}

For the ATmega644 family an RC oscillator frequency of \(8MHz\) can be selected.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega644freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1284p &          8M & 0xC2  & 19.2k & -8  & 8416k & 7  & 7882k  & 4  & 7989k \\
    \hline
mega644p &          8M & 0xC2  & 19.2k &  -12 & 8416k & 3  & 7871k  & -1  & 8009k \\
    \hline
mega324p &          8M & 0xC2  & 19.2k &  -12 & 8398k & 3  & 7885k  & 0  & 7976k \\
    \hline
mega164p &          8M & 0xC2  & 19.2k &  -5  & 8401k & 4  & 7888k  & 2  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega644 family}
  \label{tab:mega644freq}
\end{table}

\subsection{RC-Generator check of the ATmega645 family}

For the ATmega645 family an RC oscillator frequency of \(8MHz\) can be selected.
Bei der ATmega645 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gew√§hlt werden.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega645freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega165p &         8M & 0xE2  & 57.6k & -6  & 8235k &  7  & 7718k  & -1  & 8015k \\
    \hline
mega325  &         8M & 0xE2  & 38.4k & -10 & 8403k &  5  & 7868k  &  1  & 7992k \\
    \hline
mega645 &          8M & 0xE2  & 57.6k &  0  & 8253k & 12  & 7726k  & 5  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega645 family}
  \label{tab:mega645freq}
\end{table}

Beim ATmega645 ist der Betrieb der seriellen Schnittstelle ohne OSCCAL Korrektur gerade noch m√∂glich.
Sicherer ist aber der Betrieb mit OSCCAL\_CORR=5, da dann die 8MHz besser eingehalten werden. 

\subsection{RC-Generator check of the ATmega649 family}

For the ATmega649 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega649freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega169 &          8M & 0xE2  & 57.6k &  -9  & 8250k & 2  & 7864k  & -2  & 8010k \\
    \hline
mega329 &          8M & 0xE2  & 38.4k &  -2  & 8330k & 7  & 7877k  &  4  & 8013k \\
    \hline
mega649 &          8M & 0xE2  & 38.4k &  -2  & 8370k & 8  & 7895k  &  6  & 7988k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega649 family}
  \label{tab:mega649freq}
\end{table}

\subsection{RC-Generator check of the ATmega2560 family}

For the ATmega2560 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega2560freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1281 &          8M & 0xC2  & 38.4k &  -5 & 8405k & 5 & 7871   & 2  &  8012k \\
    \hline
mega2561 &          8M & 0xC2  & 38.4k &  -8 & 8363k & 4  & 7870k  & 1  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega2560 family}
  \label{tab:mega2560freq}
\end{table}

Loading of more than 128Kbyte data was successfully tested with the ATmega2561.
Normally the user data for the flash memory starts withh the address 0.
This is not absolutely nessesary for data download via the serial interface.
But the initial address must be below 128K (0x20000), so that the loading
of data into the upper flash memory half works.
The option VIRTUAL\_BOOT\_PARTITION can not be used by processors with
more than 128Kbyte flash memory.

\subsection{RC-Generator check of the ATtiny4313 family}

The ATtiny4313 und the ATtiny2313 can select a RC-generator frequency of
\(8MHz\) and \(4MHz\) with the Low-fuse.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The table~\ref{tab:tiny4313freq} shows the results of the frequeny measurement
at \(4MHz\) and \(8MHz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
tiny4313 &         8M & 0xE4  & 38.4k &  -4  & 8342k & 0  & 7975k  & -1  & 7983k \\
         &            &       &       &  -2  & 8326k & 3  & 7905k  & 1  & 8010k \\
    \hline
tiny2313 &         8M & 0xE4  & 38.4k &  -4  & 8400k & 3  & 7909k  &  2  & 7980k \\
    \hline
tiny4313 &         4M & 0xE2  & 38.4k &  -6  & 4193k & -3  & 3976k  & -3  & 3976k \\
         &            &       &       &   1  & 4169k & 6  & 3961k  & 5  & 4017k \\
    \hline
tiny2313 &         4M & 0xE2  & 38.4k &   0  & 4160k & 6  & 3960k  &  5  & 3998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny4313 family}
  \label{tab:tiny4313freq}
\end{table}

For all three checked ATtinys of this series the setting of the frequency was difficult
because a small OSCCAL correction results to a relatively strong frequency change.


\subsection{RC-Generator check of the ATtiny84 family}

The ATtiny84 family can select the \(128kHz\) clock of the watch dog additional
to the \(8MHz\) internal RC-generator as the main clock.
But the \(128kHz\) clock can not be adjusted. If you use this clock,
you can only correct the generated baud rate by selecting another baud rate value.
For a ATtiny24a I have checked the generated baud rate. Instead of the selected
2400 Baud I could measure only 2170 Baud.
This results to a frequency error of about 9.6\%, which is much too high for
using it without a correction.
If I select a baud rate of 2640 Baud for the optiboot, the download could operate with 
2400 Baud. The measured clock frequency of the processor was \(115.2kHz\) instead
of the \(128kHz\).
The table~\ref{tab:tiny84freq} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny84 &          8M & 0xE2  & 19.2k &  -6  & 8453k & 14  & 7673k  & 5  & 8019k \\
    \hline
attiny44a &         8M & 0xE2  & 19.2k &  -16  & 8367k & 3  & 7673k  & 7  & 7984k \\
    \hline
attiny24a &         8M & 0xE2  & 19.2k &  -4  & 8388k & 11  & 7685k  & 4  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny84 family}
  \label{tab:tiny84freq}
\end{table}

\subsection{RC-Generators check of the ATtiny85 family}

The ATtiny84 family can select a \(8MHz\) and a \(6.4MHz\) RC-generator and
a \(128kHz\) clock of the watchdog circuit.
The \(6.4MHz\) RC-generator clock is allways scaled to \(1.6Mhz\) for
the processor clock.
The \(128kHz\) clock can not be calibrated. If you wish to use this clock,
you can adjust the baud rate only by selecting a corrected baud rate value.
The first table~\ref{tab:tiny85freq8} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &          8M & 0xE2  & 38.4k &  -4  & 8370k &  9  & 7714k  & 3  & 8012k \\
    \hline
attiny45  &         8M & 0xE2  & 38.4k &  -4  & 8400k & 9  & 7706k  & 3  & 8030k \\
    \hline
attiny25  &         8M & 0xE2  & 38.4k &  -9  & 8424k & 46  & 7724k  & 40  & 8034k \\
attiny25  &         8M & 0xE2  & 38.4k &  -12  & 8399k & 7  & 7680k  & -2  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(8MHz\) operation}
  \label{tab:tiny85freq8}
\end{table}

The setting values for the ATtiny25 look strange, but in the case of correction 3
the OSCCAL value has fallen below the number 128 and is therefore in a different
setting range.
Not before a correction value of 34 a frequency of \(8364kHz\) was reached again,
at which a operation of the serial interface was possible.
A simular frequency could be selected with the correction value -6 in the other
setting range.
The next table~\ref{tab:tiny85freq1} shows the results of the frequeny measurement
at the \(1.6Mhz\) operation for the checked processors.
The RC-generator operates at \(6.4Mhz\), but this frequency is allways divided
ba factor 4 for the processor.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xD3  & 9.6k &  -7  & 1684k &  9  & 1547k  & 2  & 1603k \\
    \hline
attiny45  &        1.6M & 0xD3  & 9.6k &  -5  & 1684k & 11  & 1559k  & 4  & 1603k \\
    \hline
attiny25  &        1.6M & 0xD3  & 9.6k &  -7   & 1689k & 10 & 1543k  & 3  & 1602k \\
attiny25  &        1.6M & 0xD3  & 9.6k &  -10  & 1680k & 3  & 1550k  & -3  & 1609k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(1.6MHz\) operation}
  \label{tab:tiny85freq1}
\end{table}

The operation with \(1.6MHz\) clock frequency has not shown the anomaly of the
OSCCAL setting for the ATtiny25.
All checked examples can use the serial interface without any correction
at this frequency.
The ATtiny84 processor family can also use a PLL-oscillator, which is controlled
with the internal \(8MHz\) RC generator. The PLL-oscillator can operate at
\(64MHz\) or at \(32MHz\) clock, which is typically used for the T1 counter.
If you use the PLL-clock for the processor, you can only select the \(64MHz\) operation
and the clock is scaled by factor 4. So you will get a resulting \(16MHz\) clock
for the processor.
The table~\ref{tab:tiny85freq16} shows the measured results.
As expected, these results do not differ significantly from the \(8MHz\) results.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xF1  & 38.4k &  -4  & 16.87M &  10  & 15.41M  & 4  & 16.02M \\
    \hline
attiny45  &        1.6M & 0xF1  & 38.4k &  -4  & 16.87M & 10  & 15.41M  & 4  & 15.95M \\
    \hline
attiny25  &        1.6M & 0xF1  & 38.4k &  -9   & 16.91M & 47 & 15.38M  & 41  & 16.03M \\
attiny25  &        1.6M & 0xF1  & 38.4k &  -11  & 16.82M & 7  & 15.43M  & -2  & 16.07M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(16MHz\) operation}
  \label{tab:tiny85freq16}
\end{table}

\subsection{RC-Generators check of the ATtiny841 family}

The ATtiny841 and the ATtiny441 can use also a internal \(8MHz\) RC-generator,
which can be adjusted.
For the support of this family some special modifications must be done
at the optiboot bootloader source.
The table~\ref{tab:tiny841freq8} shows the results of some checked examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny841 &          8M & 0xE2  & 38.4k &  -4  & 8369k & 10  & 7861k  & 6  & 8003k \\
          &             &       &       &  -5  & 8389k &  9  & 7874k  & 6  & 7990k \\
    \hline
attiny441  &         8M & 0xE2  & 38.4k &  -4  & 8399k & 10 & 7870k  & 7  & 7985k \\
           &            &       &       &  -4  & 8380k &  9 & 7900k  & 7  & 7985k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny841 family at \(8MHz\) operation}
  \label{tab:tiny841freq8}
\end{table}

For all checked examples the serial interface can be used without the
OSCCAL correction.


\subsection{RC-Generators check of the ATtiny861 family}

The ATtiny861 family can use a \(8MHz\) internal RC generator, a PLL oscillator
and the \(128kHz\) clock of the watchdog circuit.
The \(128kHz\) clock of the watchdog circuit can not be calibrated und is
therefore limited for use with the bootloader application.
The PLL-Oscillator has a resulting frequency of \(16MHz\) for the processor,
which can only synchronized by the internal RC-generator.
Therefore you can not use the PLL-oscillator with the T1 counter
for precise time measurements.
The first table~\ref{tab:tiny861freq8} shows the OSCCAL correction results of the checked examples
for the \(8MHz\) operation.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny861 &          8M & 0xE2  & 38.4k &  -2  & 8415k & 18  & 7693k  & 9  & 8007k \\
          &             &       &       &  -1  & 8436k & 19  & 7678k  & 10 & 8011k \\
    \hline
attiny461  &         8M & 0xE2  & 38.4k &  -2  & 8418k & 17 & 7690k  & 9  & 7995k \\
           &            &       &       &  -4  & 8380k & 14 & 7695k  & 3  & 8030k \\
    \hline
attiny261  &         8M & 0xE2  & 38.4k &  -4  & 8403k & 17 & 7710k  & 9  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny861 family at \(8MHz\) operation}
  \label{tab:tiny861freq8}
\end{table}

For the ATtiny261 I have omitted the optional LED-flashing at the start of the optiboot
to get enough space for the test program (option LED\_START\_FLASHES=0).


\subsection{RC-Generators check of the ATtiny88 family}

The ATtiny88 family can select a internal \(8MHz\) RC-generator and a
internal \(128kHz\) generator as processor clock.
You can also select a factor 8 scaler for the processor clock with the Low-fuse.
The table~\ref{tab:tiny88freq} shows the calibration results of two examples of this family.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny88 &          8M & 0xE2  & 38.4k &  -4  & 8397k & 15  & 7682k  & 6  & 8013k \\
    \hline
attiny48 &         8M & 0xE2  & 38.4k &  -5  & 8385k & 12  & 7739k  & 5  & 7995k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny88 family}
  \label{tab:tiny88freq}
\end{table}

Both examples can operate the serial interface without a frequency correction.
But the processor clock will match the \(8MHz\) better, if you choose
a correction value of 5 (6).

\subsection{RC-Generator check of the ATtiny1634}

I have checked the \(8MHz\) internal RC-generator of the ATtiny1634
with two examples.
The ATtiny1634 support two additional calibration register for adjusting the
temperature drift of the \(8MHz\) RC-generator.
In the table~\ref{tab:tiny1634freq} I have not checked the effect of
the temperature drift compensation.
Additional to the \(8MHz\) RC-generator the ATmega1634 can also adjust
the internal \(32kHz\) generator with a additional calibration register (OSCCAL1).
This adjustment is currently unsupported by the Optiboot bootloader.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
         8M & 0xE2  & 19.2k &  -5  & 8404k &  9  & 7867k  & 6  & 7983k \\
         8M & 0xE2  & 19.2k &  -7  & 8410k &  7  & 7867k  & 4  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny1634}
  \label{tab:tiny1634freq}
\end{table}

\subsection{RC-Generators check of the AT90PWM family}

Beside the usual \(8MHz\) internal RC-generator the AT90PWM family can also
select a PLL-oscillator with a resulting processor clock of \(16MHz\).
The PLL-oscillator is synchronized by the internal \(8MHz\) RC-generator.
The table~\ref{tab:t90pwmfreq} shows the OSCCAL correction results
of two examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90pwm2b &         8M & 0xE2  & 38.4k &  -13  & 8350k & -1  & 7862k  & -5  & 8020k \\
    \hline
at90pwm3  &         8M & 0xE2  & 38.4k &  -10  & 8359k &  4  & 7885k  & 1  & 7991k \\
    \hline
at90pwm2b &        16M & 0xE3  & 38.4k &  -14  & 16.74M & -1  & 15.74M  & -4  & 15.97M \\
    \hline
at90pwm3  &        16M & 0xE3  & 38.4k &  -10  & 16.76M &  4  & 7885k  & 2  & 15.97M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the AT90PWM family}
  \label{tab:t90pwmfreq}
\end{table}

The AT90PWM2B can not use the serial interface without a OSCCAL correction.
