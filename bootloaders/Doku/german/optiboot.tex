\chapter{Der optiboot Bootloader für AVR Mikrocontroller}

\section*{}
Der optiboot Bootloader wurde in der Sprache C von Peter Knight und
Bill Westfield entwickelt. Die Version 6.2 habe ich als Basis
für die hier beschriebene überarbeitete Assembler Version benutzt.
Dabei möchte ich betonen, daß ich den optiboot Bootloader nicht
neu erfunden habe, sondern lediglich weiter optimiert. 
Viele Anpassungen an verschiedene Zielprozessoren und spezielle
Platinenentwürfe waren bereits in der Version 6.2 vorhanden.
Es werden Teile des STK500 Kommunikations-Protokols benutzt,
die in der AVR061~\cite{stk500} von Atmel veröffentlicht wurde.


\section{Änderungen und Weiterentwicklung von Version 6.2}
Im wesentlichen habe ich das komplette Programm in die Assembler-
Sprache umgeschrieben und die Makefile so angepasst, daß die Programmlänge
automatisch weiterverarbeitet wird und damit die Startadresse
des Bootloaders sowie die Fuses des ATmega richtig eingestellt werden.
Die eingeschlagene Lösung erzeugt während der Abarbeitung der Einzelschritte
für die Erzeugung des Programmcodes für den Bootloader noch weitere
kleine Dateien, welche in den nachfolgenden Schritten für die Anpassung
der Start-Adresse und der Fuses erforderlich sind.
Die Startadresse für den jeweiligen Zielprozessor ist abhängig von
der vorhandenen Flash-Speichergröße,
dem Speicherbedarf für den aktuellen Bootloader-Code und
der Kachelgröße, die für Bootloader beim Zielprozessor zur Verfügung steht.
Als Kachelgröße bezeichne ich die kleinste Speichergröße für Bootloader,
die der jeweilige Prozessor zur Verfügung stellen kann.


Bei Prozessoren wie der ATtiny84, die keine Bootloader Startadresse einstellen können,
wird die Seitengröße des Flash-Speichers für die Berechnung benutzt.
Beim ATtiny84 sind das 64 Bytes. Damit liegt die Startadresse des Bootloaders immer
am Anfang einer Flash Speicherseite. 

Bei allen anderen Zielprozessoren kann der Bootloader-Bereich mit den
Fuse-Bits BOOTSZ1 und BOOTSZ0 eingestellt werden (jeweils mit den Werten 0 und 1).
Wenn man die beiden Bits zusammensetzt, ergibt sich daraus die
Bootloader-Größe BOOTSZ mit Werten zwischen 0 und 3.
Dabei bedeutet 3 immer den kleinsten mögliche Bootloader Speicherbereich.
Der Wert 2 gibt den doppelten, der Wert 1 den vierfachen und
der Wert 0 den acht-fachen Speicherbereich vor.
Die Tabelle~\ref{tab:bootsz} auf Seite~\pageref{tab:bootsz} gibt einen
Überblick für verschiedene Zielprozessoren.

\section{Automatische Größenanpassung in der optiboot Makefile}

Die Bootloader Startadresse und die benötigte Bootloadergröße wird
automatisch in der Makefile angepasst. Für die Berechnungen werden
einige Zwischendateien erzeugt, was nur zusammen
mit den folgenden Linux Werkzeugen funktioniert:
\begin{description}
\item [bc] ein einfacher Rechner, der die Eingabe- und Ausgabe-Werte
sowohl dezimal als auch sedezimal (hex) verarbeiten kann.
\item [cat] gibt den Inhalt von Dateien auf der Standard-Ausgabe aus.
\item [cut] kann Teile von Zeilen einer Textdatei ausschneiden.
\item [echo] gibt den angegebenen Text auf der Standard-Ausgabe aus.
\item [grep] gibt nur Zeilen einer Textdatei mit dem angegebenen Suchtext aus.
\item [tr] kann Text-Zeichen ersetzen oder löschen.
\end{description}

Bisher ist die Funktion der Makefile nur mit einem Linux-System getestet.
Wahrscheinlich ist die Benutzung unter Windows nur möglich,
wenn das Cygwin Paket installiert wird.

Um die erzeugten Zwischendateien braucht man sich im Regelfall nicht zu kümmern. Hier
möchte ich aber wenigstens die Namen und die Bedeutung erwähnen:
\begin{description}
\item [BootPages.dat] enthält die Zahl der vom Bootloader benötigten Seiten.
Bei Prozessoren mit Bootloader Unterstützung kann die Zahl nur 1, 2, 4 oder 8 sein und
gibt an, das wie-vielfache der Mindest-Bootloadergröße verwendet wird.
Bei der virtuellen Bootloader Seite kann die Zahl beliebig sein und gibt die Zahl der
benötigten Flash-Speicherseiten an.
\item [BOOTSZ.dat] enthält eine Zahl zwischen 0 und 3 für die Einstellung der BOOTSZ0 und BOOTSZ1 Bits.
\item [BL\_StartAdr.dat] enthält die Startadresse des Bootloaders im sedezimal (hex) Format.
Die Startadresse wird berechnet aus der Flash-Speichergröße des jeweiligen Zielprozessors und
aus der Zahl der benötigten Speicherseiten.
\item [EFUSE.dat] enthält im sedezimal Format der Wert für die efuse. Die Makefile entscheidet
 abhängig vom Zielprozessor, ob diese Datei verwendet wird.
\item [HFUSE.dat] enthält im sedezimal Format der Wert für die hfuse. Die Makefile entscheidet
 abhängig vom Zielprozessor, ob diese Datei verwendet wird.
\end{description}

\section{Zielvorgaben für optiboot Makefile}

Die Steuerung des Ablaufs für die Generierung der Programmdaten aus
dem Quellcode ist in der Makefile festgelegt.
Außer der  Haupt Makefile gibt es noch weitere drei Erweiterungen
der Makefile, die automatisch von der Haupt Makefile integriert werden:
Makefile.1284, Makefile.atmel, und Makefile.extras .
Dabei können verschiedene Konfigurationen auch für einen Prozessortyp
festgelegt worden sein. In der Tabelle~\ref{tab:processors} sind die derzeit vordefinierten
Konfigurationen für AVR Prozessoren angegeben. Im Prinzip ist diese Liste natürlich erweiterbar.
Die einstellbaren Parameter sind aber auch in der Aufrufzeile des
make Programms als Parameter oder auch als Umgebungsvariable der Shell
einstellbar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
             Name  & MCU & AVR\_ & total & Flash & BP\_ & LFUSE & HFUSE & EFUSE  \\
                   &     & FREQ  & Flash & page  & LEN  &       &       &        \\
                   &     &       &  size & size  &      &       &       &        \\
    \hline
    \hline
         attiny84 & t84   & 16M? &  8K   &  64   & (64) &  62   &  DF   & FE \\
    \hline
         atmega8  & m8    & 16M  &  8K   &  64   & 256  &  BF   &  CC   &  - \\
    \hline
         atmega88 & m88   & 16M  &  8K   &  64   & 256  &  FF   &  DD   &  04 \\
    \hline
       atmega16   & m16   & 16M  &  16K  & 128   & 256  &  FF   &  9C   &  - \\
    \hline
       atmega168  &  m168  & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
       atmega168p &  m168p & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
    \hline
       atmega32   &  m32   & 16M  &  16K & 128   & 256  &  BF   &  CE   &  - \\
    \hline
       atmega328  &  m328  & 16M  &  32K & 128   & 512  &  FF   &  DE   &  05 \\
       atmega328p & m328p & 16M  &  32K  & 128   & 512  &  FF   &  DE   &  05 \\
    \hline
       atmega644p & m644p & 16M  &  64K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1284  & m1284  & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
     atmega1284p & m1284p & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1280  & m1280  & 16M  &  128K & 256   & 1K   &  FF   &  DE   &  05 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Prozessor targets für optiboot Makefile}
  \label{tab:processors}
\end{table}

Alle Angaben für Größen sind in Bytes angegeben, die Werte für die Fuses sind die sedezimalen
Werte (hex). Die Frequenz-werte werden in Hz angegeben, 16M entspricht also 16000000 Hz.
Die Standard Baud-Rate für die serielle Schnittstelle beträgt immer 115200.

Neben den universellen Konfigurationen gibt es auch Konfigurationen für bestimmte
Platinen oder Arbeitsumgebungen.
Die Tabelle~\ref{tab:boards} zeigt die unterschiedlichen Einstellungen.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
    \hline
             Name  & MCU & AVR\_ & BP\_ & L     & H     & E     & BAUD\_ & LED & SOFT\_ \\
                   &     & FREQ  & LEN  &  FUSE & FUSE  &  FUSE & RATE &     & UART \\
    \hline
    \hline
       luminet     & t84 &  1M   & 64v &  F7   &  DD   &  04   & 9600 & 0x  &  -   \\

    \hline
         virboot8  & m8    & 16M & 64v &       &       &       &      &     &      \\
    \hline
       diecimila  &  m168 & (16M) &     &  F7   &  DD   &  04   &      & 3x  &  -   \\
       lilypad    &  m168  & 8M  &      &  E2   &  DD   &  04   &  -   & 3x  &  -   \\
       pro8       &  m168  & 16M &      &  F7   &  C6   &  04   &  -   & 3x  &  -   \\
       pro16      &  m168  & 16M &      &  F7   &  DD   &  04   &  -   & 3x  &  -   \\
       pro20      &  m168  & 16M &      &  F7   &  DC   &  04   &  -   & 3x  &  -   \\
    atmega168p\_lp&  m168  & 16M &      &  FF   &  DD   &  04   &  -   &     &  -   \\
   xplained168pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
       virboot328  & m328p & 16M & 128v &       &       &       &      &     &  -   \\
    atmega328\_pro8& m328p & 8M  &      &  FF   &  DE   &  05   &  -   & 3x  &  -   \\
   xplained328pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
   xplained328p   &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
        wildfire  & m1284p & 16M &      &       &       &      &   -   & 3xB5 &      \\
    \hline
       mega1280    & m1280 & 16M &      &  FF   &  DE   &  05   &  -   &     &  -   \\
    \hline
    \end{tabular}
  \end{center}
  \caption{vorkonfigurierte targets für optiboot Makefile}
  \label{tab:boards}
\end{table}

\section{Die Optionen für die optiboot Makefile}

Mit den Optionen wird die Eigenschaft des optiboot Bootloaders eingestellt.
Beispielsweise kann mit der Option SOFT\_UART veranlasst werden, daß ein
Softwareprogramm für die serielle Kommunikation verwendet werden soll.
Sonst wird, wenn vorhanden, die auf dem Chip integrierte  serielle Schnittstelle
mit den Pins TX (Transmit = senden) und RX (Receive = empfangen) benutzt.
Bei mehreren integrierten seriellen Schnittstellen wird normalerweise die erste
Schnittstelle mit den Nummer 0 verwendet. Es kann aber auch jede andere vorhandene
Schnittstelle mit der Option UART vorgegeben werden (UART=1 für die zweite Schnittstelle).
Bei der Hardware UART Schnittstelle sind die Pins für Empfangen (RX) und Senden (TX)
fest verknüpft. Bei der Software-Lösung für die serielle Schnittstelle sind alle Pins
des AVR Prozessors frei für die serielle Kommunikation wählbar. Die einzige Bedingung
ist, daß die Pins für digitale Eingabe (RX) beziehungsweise Ausgabe (TX) geeignet sind.
Näheres zu den möglichen Optionen findet man in der Übersicht~\ref{tab:options1}
und \ref{tab:options2}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name der        & Beispiel       & Funktion                                            \\
    Option         &                &                                                     \\
    \hline
    \hline
    F\_CPU         & F\_CPU=8000000 & Teilt dem Programm die Taktrate des Prozessors mit. \\
                   &                & Die Angabe erfolgt in Hz (Schwingungen pro Sekunde. \\
                   &                & Das Beispiel gibt eine Frequenz von 8 MHz an. \\
    \hline
    BAUD\_RATE     & BAUD\_         & Gibt die Baud-Rate für die serielle Kommunikation an. \\
                   &  RATE=9600      & Es werden immer 8 Datenbits ohne Parity verwendet. \\
                   &                & Werte unter 100 aktivieren eine Messung and Anpassung \\
                   &                & der Baudrate.  \\
    \hline
    SOFT\_UART     & SOFT\_UART=1   & Wählt Software-Lösung für die serielle Kommunikation. \\
    \hline
    UART\_RX        & UART\_RX=D0   & Gibt den Port und die Bitnummer für die seriellen  \\
                   &                & Empfangsdaten an. Das Beispiel nimmt               \\
                   &                & Bit 0 des D Ports für den seriellen Eingang.\\
    \hline
    UART\_TX        & UART\_TX=D1   & Gibt den Port und die Bitnummer für die seriellen  \\
                   &                & Sendedaten an.  Das Beispiel nimmt                 \\
                   &                & Bit 1 des D Ports für den seriellen Ausgang.\\
    \hline
    UART           & UART=1         & Wählt für die  serielle Schnittstelle des Chips. \\
                   &                & Eine Auswahl setzt das Vorhandensein mehrerer \\
                   &                & Schnittstellen voraus. \\
    \hline
 LED\_START\_      & LED\_START\_   & Wählt für die Anzahl der Blink-Zyklen \\
   FLASHES         &   FLASHES=3    & für die Kontroll-LED.                            \\
                   &                & Bei 1 oder -1 wird nur einmal geblinkt ohne Wiederholung. \\
                   &                & Negative Vorgaben bewirken, daß in der Programmschleife \\
                   &                & das RX Bit der seriellen Schnittstelle überwacht wird. \\
                   &                & Sobald eingehende RX-Daten festgestellt werden, \\
                   &                & wird die Schleife abgebrochen. Bitte beachten Sie, \\
                   &                & daß das Blinken den Start des Anwenderprogramms \\
                   &                & verzögert. \\
    \hline
 LED               & LED=B3         & Wählt das Port-Bit für die  Kontroll-LED. \\
                   &                & Beim Beispiel würde eine an das Bit 3 des Port B \\ 
                   &                & angeschlossene LED blinken. Bei der \\
                   &                & LED\_START\_FLASHES  Option  blinkt die LED die\\
                   &                & angegebene Anzahl vor dem Kommunikations-Start. \\
                   &                & Mit der LED\_DATA\_FLASH Option leuchtet die \\
                   &                & LED auch während des Wartens auf Daten. \\
    \hline
 LED\_DATA\_       & LED\_DATA\_    & Die Kontroll-LED leuchtet während des Wartens auf \\
      FLASH        &    FLASH=1     & Empfangsdaten der seriellen Kommunikation.\\
    \hline
 TIMEOUT\_MS       & TIMEOUT\_      & Diese Option gibt eine Zeitschranke in Millisekunden \\
                   &  MS=2000       & vor für den Empfang von Boot-Daten. Nach dieser Zeit\\
                   &                & wird der Bootvorgang abgebrochen und versucht, das \\
                   &                & Anwenderprogramm zu starten. Mögliche Werte für \\
                   &                & TIMEOUT\_MS sind 500, 1000, 2000, 4000 und 8000. \\
                   &                & Der tatsächlich mögliche Wert kann abhängig vom \\
                   &                & Prozessor aus 2 Sekunden begrenzt sein. \\
                   &                & Wenn kein TIMEOUT\_MS angegeben wird, wird die \\
                   &                & Zeitschranke auf 1 Sekunde gesetzt. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Wichtige Optionen für die optiboot Makefile}
  \label{tab:options1}
\end{table}

Bei Betrieb mit internem RC-Generator ist es durchaus möglich, daß ein serieller Datentransfer
nicht auf Anhieb gelingt. Das ist prinzipiell auch unabhängig davon, ob die Hardware UART
Schnittstelle oder eine Softwarelösung (SOFT\_UART) benutzt wird. Ohne zusätzliche Messungen
ist man dann auf Probieren mit der OSCCAL\_CORR angewiesen. Einen Hinweis kann
das Datenblatt des Prozessors liefern. Hier ist beschrieben, bei welcher Betriebsspannung
und bei welcher Temperatur der RC-Oszillator kalibriert wurde. Außerdem ist der
prinzipielle Verlauf der Frequenzänderung mit der Betriebsspannung, mit der Temperatur und
mit OSCCAL-Änderung beschrieben. 


Weitere Optionen sind in der Tabelle~\ref{tab:options2} aufgezählt. 
Diese Optionen sind nur für Software-Untersuchungen, die Frequenzkalibration des RC-Generators
 und für Prozessoren ohne Bootloader-Bereich interessant.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name der        & Beispiel       & Funktion                                            \\
    Option         &                &                                                     \\
    \hline
    \hline
    SUPPORT\_      & SUPPORT\_      & Wählt für das Bootloader-Programm die Lese- und Schreib- \\
    EEPROM         &  EEPROM=1      & Funktion für EEproms. Wenn als Quelle das Assembler- \\
                   &                & Programm gewählt wurde, ist die EEprom Unterstützung \\
                   &                & ohne gesetzte Option eingeschaltet, kann aber abgeschaltet\\
                   &                & werden, wenn die SUPPORT\_EEPROM Option auf 0 \\
                   &                & gesetzt wird. \\
                   &                & Bei der C-Quelle muß die Funktion mit der Option \\
                   &                & eingeschaltet werden (Standard = aus). \\
    \hline
 C\_SOURCE         & C\_SOURCE=1    & Wählt als Programmquelle das C-Programm anstelle des  \\
                   &                & Assembler-Programms (0 = Assembler).\\
                   &                & Die Assembler Version benötigt weniger Speicherplatz. \\
    \hline
 BIGBOOT           & BIGBOOT=512    & Wählt zusätzlichen Speicherverbrauch für das Bootloader- \\
                   &                & Programm. Das dient nur zum Test der automatischen \\
                   &                & Anpassung an die Programmgröße in der Makefile. \\
    \hline
VIRTUAL\_          & VIRTUAL\_       &  Ändert die Programmdaten eines Anwenderprogramms \\
 BOOT\_            & BOOT\_          & so ab, daß der Bootloader beim Reset angesprochen \\
 PARTITION         & PARTITION       & wird. Für den Start des Anwenderprogramms wird \\
		   &                 & ein anderer Interrupt-Vektor benutzt.          \\
    \hline
 save\_vect\_      & save\_vect\_    & Wählt eine Interrupt-Vektornummer für die  \\
      num          &    num=4        & VIRTUAL\_BOOT\_PARTITION Methode aus.        \\
    \hline
 OSCCAL\_          & OSCCAL\_       & Mit der Option OSCCAL\_CORR kann der interne \\
 CORR              & CORR=5         & 8~MHz RC-Generator des AVR abgeglichen werden. \\
                   &                & Ist bei Quarz-Betrieb oder externem Takt unwirksam! \\
                   &                & Der Korrekturwert wird vom voreingestellten OSCCAL Byte \\
                   &                & abgezogen. Bei positivem Korrekturwert wird die Frequenz \\
                   &                & normalerweise niedriger. Da die erzeugte Baud-Rate direkt \\
                   &                & vom Prozessortakt abhängt, ist ein richtig eingestellter \\
                   &                & Prozessortakt für eine erfolgreiche serielle Kommunikation \\
                   &                & wichtig. Der Wert sollte zwischen -20 und +20 liegen. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Weitere Optionen für die optiboot Makefile}
  \label{tab:options2}
\end{table}

\section{Benutzung von optiboot ohne Bootloader-Bereich}

Für Prozessoren ohne speziellen Bootloader-Bereich im Flash-Speicher wie dem ATtiny84 ist
eine Möglichkeit vorgesehen, trotzdem optiboot zu benutzen. 
Diese Funktion wird mit der Option VIRTUAL\_BOOT\_PARTITION gewählt.
Dabei wird im Anwenderprogramm auf der Reset-Vektoradresse die Start-Adresse des Bootloaders
eingetragen damit bei einem Reset immer der Bootloader zuerst angesprochen wird.
Die Start-Adresse des Anwender-Programms wird dabei auf die Adresse eines anderen
Interrupt-Vektors verlegt. Dieser Interrupt-Vektor sollte vom Anwenderprogramm nicht benutzt werden.
Wenn der Bootloader in angemessener Zeit keine Daten von der seriellen Schnittstelle
empfängt, springt er zu dem Sprungbefehl, der auf der ,,Ersatz''-Vektoradresse steht und
startet damit das Anwenderprogramm.
Die Abbildung~\ref{fig:VectorMove} soll die Veränderung verdeutlichen.

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/VectorMove.eps}
\caption{Veränderung der Programmdaten durch optiboot}
\label{fig:VectorMove}
\end{figure}

Auf der linken Seite ist der Inhalt der Datei dargestellt, welche die Programmdaten (.hex) enthält.
Rechts daneben ist der Inhalt des Flash-Speichers dargestellt, wie er vom Optiboot Bootloader
geschrieben wird. An zwei Interruptvektor-Adressen wurde der Inhalt verändert.
Einmal wurde auf dem Reset-Vektor 0 der Optiboot Bootloader eingetragen und zum anderen
auf der ,,Ersatz''-Vektor Adresse 4 ein Sprung zum Start des Applikations-Programms eingetragen. 
Eine Schwierigkeit bei der Methode entsteht aber dadurch, daß die Programmdaten nach
der Programmierung meistens zur Kontrolle zurückgelesen werden.
Damit bei der Kontrolle keine Fehler gemeldet werden, gibt Optiboot nicht den wirklichen Inhalt
der Interrupt-Vektortabelle zurück, sondern den Zustand vor seiner Manipulation.
Die Sprung-Adresse im Reset-Vektor kann dafür aus den Daten des ,,Ersatz''-Interruptvektors rekonstruiert werden.
Aber die ursprünglichen Daten des ,,Ersatz''-Interruptvektors wären verloren, da sie an keiner
Stelle der Vektortabelle wiederzufinden sind.
Optiboot benutzt zum Sichern des Original-Inhaltes des ,,Ersatz''-Vektors deshalb die beiden letzten
Bytes des EEprom-Speichers.
Damit ist eine Kontrolle der Programmdaten solange möglich, wie die beiden letzten Bytes
des EEproms nicht überschrieben werden.
Selbst wenn die EEprom Daten überschrieben werden, bleibt der Bootloader funktionsfähig.
Nur die Kontrolle (verify) der Programmdaten ist dann nicht mehr möglich. Bei der Adresse
des ,,Ersatz''-Interruptvektors wird dann ein Fehler gemeldet.

Bei Prozessoren mit mehr als 8 kByte Flash Speicher werden zwei Befehlsworte für jeden Interrupt-Vektor
vorgesehen. Normalerweise stehen auf diesen Doppelworten jmp Befehle mit den jeweiligen Sprungzielen.
Auch diese Art der Vektortabelle wird von Optiboot berücksichtigt. Wenn aber für das Bindeprogramm
(Linker avr-ld) die Option --relax verwendet wird,
werden alle jmp Befehle durch die kürzeren rjmp Befehle ersetzt,
wenn dies bei der jeweiligen Sprungadresse möglich ist.
Dies wird derzeit nicht von optiboot berücksichtigt.
Das Optiboot Programm geht fest davon aus, daß in der Vektortabelle jmp Befehle stehen,
wenn mehr als 8 kByte Flash-Speicher vorhanden sind.
Deshalb wird die VIRTUAL\_BOOT\_PARTITION Methode meistens nicht funktionieren, wenn die --relax Option
beim Programmbinden benutzt wurde!


Weiter ist zu beachten, daß bei Benutzung der VIRTUAL\_BOOT\_PARTITION Option für Prozessoren, die auch
die normale Bootloader Unterstützung bieten, das BOOTRST Fuse Bit nicht aktiviert wird.
Der Grund hierfür ist, daß bei Benutzung der VIRTUAL\_BOOT\_PARTITION die Start-Adresse des Bootloaders
auf einer anderen Adresse liegen kann wie bei der normalen Bootloader Unterstützung.
Bei Benutzung der Option VIRTUAL\_BOOT\_PARTITION kann die Startadresse auf jedem Anfang einer
Seite des Flash-Speichers liegen. Bei der normalen Bootloader Unterstützung kann immer nur das
einfache, doppelte, vierfache oder achtfache einer Mindest-Bootloadergröße berücksichtigt
werden (BOOT\_SZ Fuse-Bits), wie es in Abbildung~\ref{fig:pages} auf Seite~\pageref{fig:pages}
dargestellt wird.

\section{Die Möglichkeiten der seriellen Schnittstelle mit der verwendeten Software}

Das Programm für die Erzeugung und Verarbeitung der elektrischen Signale ist in AVR-Assembler geschrieben.
Die Arbeitsweise ist von der Veröffentlichung von Atmel übernommen.
Allerdings sind einige Besonderheiten eingebaut. 
So wird beispielsweise berücksichtigt, daß nicht für alle Port Adressen die speziellen Bitbefehle SBI, CBI
bzw SBIC benutzt werden können. Das ist nur bis zur Adresse 31 (0x1f) möglich. Für etwas größere
Port Adressen von 63 (0x3f) ist noch die Verwendung spezieller Einlese (IN) und Ausgabe (OUT) Befehle
möglich. Darüber liegende Adressen können nur mit den LDS und STS Befehlen erreicht werden.
Diese Befehle benötigen sowohl zwei Takte für die Ausführung und belegen auch den doppelten
Speicherplatz im Flash (2 Worte oder 4 Byte).
Die veränderte Taktzahl für einen Schleifendurchlauf ohne eine zusätzliche Verzögerung wird 
vom Programm automatisch ermittelt.
Diese Taktzahl wird dann für die Berechnung der Verzögerungsschleife berücksichtigt,
um eine korrekte Zeit für die Übertragung eines Bits zu erreichen. 
Die Diagramme~\ref{fig:getch_timing} und~\ref{fig:putch_timing} sollen  die Erzeugung der Schleife mit
dem C-Preprozessor verdeutlichen.

\begin{figure}[H]
\centering
\scalebox{0.9}{\includegraphics[]{../FIG/uart_getch_timing.eps}}
\caption{Mögliche Varianten der getch Funktion}
\label{fig:getch_timing}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/uart_putch_timing.eps}
\caption{Mögliche Varianten der putch Funktion}
\label{fig:putch_timing}
\end{figure}

Beide Schleifen werden so erzeugt, daß für die gleichen Bedingungen von INVERS\_UART und Adresse des verwendeten
Ports die gleiche Taktzahl gebraucht wird. Damit können dann beide Funktionen die gleiche
Funktion für die notwendige Verzögerung benutzen.

\subsection{Berechnung der Verzögerungszeit}
Für die Einlesefunktion getch() wird auch die halbe Baudzeit  gebraucht.
Von der Erkennung des Startbits wird 1.5 Mal die Baud-Zeit gewartet, um das erste Datenbit
einzulesen.
Deshalb ist die Basisschleife auf die halbe Zeitdauer einer Bitübertragung ausgelegt.
Für die ganze Baudzeit wird diese Basisschleife in einer speziellen Weise zwei mal aufgerufen,
damit exakt die doppelte Zeit eingehalten wird. Sollte durch die Bildung der Hälfte der Zeit und der
nachfolgenden Verdopplung ein Takt verloren gegangen sein, wird dieser Takt durch einen zusätzlichen
NOP Befehl ausgeglichen damit die Gesamtzeit für die Übertragung eines Bits auf einen Takt genau stimmt.
Wenn bei der Schleifenzeit ein oder zwei Takte wegen der Zeitauflösung (3 Takte) fehlen,
wird das automatisch durch einen zusätzlichen Befehl ausgeglichen.
Natürlich geschieht das alles automatisch, da für die Berechnung nur die Schleifenzeit der Einlesefunktion
(getch) bzw. Ausgabefunktion (putch), die Taktfrequenz des Prozessors und die gewünschte Baudrate
bekannt sein muß. Auch die übrigen Parameter wie die Anzahl der Takte für einen Unterprogramm-Aufruf
(RCALL, RET) sind für den Zielprozessor bekannt.
Ein Nachteil der Basis-Verzögerungsschleife ist die begrenzte Anzahl Takte für die Verzögerung.
Es sind wegen des verwendeten 8-Bit Zählers maximal 256*3 Takte für die Scheifenverzögerung möglich.
Dazu kommt noch der Unterprogrammaufruf von 7 Takten, wodurch sich für die halbe Verzögrungszeit dann 775 Takte ergeben.
Dieser Wert muß verdoppelt werden (Verzögerung für eine ganze Bitzeit) und dazu noch die Schleifenzeit der
Ausgabe- bzw. Eingabe dazugezählt werden. Somit ist die höchste erzielbare Verzögerungszeit 1559 Takte.
Bei 16 MHz Taktfrequenz sind so mit maximal \(97.4\mu s\) noch nicht einmal 9600 Baud (\(104.17 \mu s\)) einstellbar.
Würde man den Zähler der Zählschleife für die Verzögerungszeit von 8 Bit auf 16 Bit erweitern,
hätte man eine noch schlechtere Auflösung als die 3 Takte der 8-Bit Variante.
Außerdem käme die Schleife wahrscheinlich nicht wie die 8-Bit Variante ohne Veränderung des Übertragssignals (carry) aus.
Dieses Problem habe ich durch die schrittweise Verdopplung der Verzögerungszeiten durch Verdopplung der
Schleifenfunktion gelöst. Mit dem C-Preprozessor wird geprüft, ob der Anfangswert für die 8-Bit Zählschleife
bei der gewählten Taktfrequenz des Prozessors und der Baudrate größer als 255 sein würde.
Für diesen Fall wird die Berechnung für einen Doppelaufruf der Schleifenfunktion wiederholt. 
Wenn dann der Anfangswert für die Zählschleife immer noch zu hoch wäre, wird der Doppelaufruf noch einmal
verdoppelt. Diese Prüfung wird derzeit bis zum Faktor 64 des Basiszeit fortgesetzt.
Bei einer Taktfrequenz von 16 MHz oder 20 MHz sind so auf jeden Fall noch 300 Baud einstellbar.
Für jede Verdopplung der Verzögerungszeit wird ein zusätzlicher Befehl (2 Byte) benötigt. 
Bei der maximal möglichen Zahl der Verdopplung werden dann 6 zusätzliche Befehle (12 Byte) im Flash belegt.
Ein Ausgleich der durch die Vorteilung möglicherweise fehlenden Takte wird hier nicht durchgeführt,
um nicht unnötig Platz im Flash zu belegen.
Da die zusätzliche Vorteilung ja nur bei Bedarf erfolgt, bleibt der Fehler der Baudzeit deutlich unter 1\% ,
weil die Zeit für eine Basisverzögerung auf einen Prozessor-Takt genau eingehalten wird.
Die Basisschleife hat mindestens 127 Durchläufe mit etwa 381 Takten. Die doppelte Verzögerungszeit
macht auch noch keinen Fehler wegen des ,,NOP'' Ausgleichs. Somit bleibt der Fehler unter 1:762,
also 0.13\%. Probleme mit der Einhaltung der Baudrate bestehen also eher für hohe Baudraten,
weil die Übertragungszeit für ein Bit nicht zum vorgegebenen Zeitraster durch den CPU-Takt paßt.
Das gleiche Problem hat dann aber auch die Hardware UART-Schnittstelle.
Ein Beispiel erläutert das Problem.
Wenn man mit \(8 MHz\) CPU-Taktrate eine Baudrate von 230400 erzeugen möchte, 
kann man entweder 34 Takte mit einer Taktzeit von \(4.25\mu s\) oder 35 Takte
mit einer Baud-Zeit von \(4.375\mu s\) verwenden. Im ersten Fall ist die Baud-Zeit
um \(2.08\%\) zu kurz, im zweiten Fall ist die Baud-Zeit um \(0.8\%\) zu lang.


\subsection{Benutzung von mehr als einer seriellen Schnittstelle}

Die Assembler Datei soft\_uart.S ist dafür ausgelegt,
von einer anderen Datei eingefügt (\#include) zu werden, welche ein
normales Assembler-Programm für die AVR-Familie beinhaltet.
Für die optiboot Applikation wird das von der Datei optiboot.S gemacht.
Die eingefügte Datei soft\_uart.S benutzt viele Anweisungen für den GNU C-Processor
und fügt eine weitere Datei uart\_delay.S ein, um eine Verzögerungsschleife
für die gewünschte Baud-Rate zu generieren.
Weil dieses Verfahren für uart\_delay.S mit anderen Parametern mehrfach wiederholt werden kann,
kann man bis zu 4 verschiedene Verzögerungsschleifen erzeugen lassen.
Diese Vorgehensweise nutzt die Datei soft\_uart.S für die Erzeugung der
getch und putch Funktion. Für beide Funktionen wird die Datei uart\_delay.S
eingefügt. Aber für den zweiten \#include wird meistens keine neue Verzögerungsschleife
produziert, weil die Parameter beim zweiten Aufruf gleich sind.
Nur bei verschiedenen Parametern wird eine neue Verzögerungsschleife generiert.
Bitte beachten Sie, daß die Aufrufe der Verzögerungsschleifen mit C-Preprozessor Makro Namen
versehen sind. Diese Makro Namen DOUBLE\_DELAY\_CALL und SINGLE\_DELAY\_CALL
werden durch die richtigen Funktionsnamen ersetzt, wenn die \#include Anweisung
vor der Befehlsfolge  für die serielle Eingabe- oder Ausgabe-Funktion steht.

Drei Konstanten müssen vor jeder Einfügung von uart\_delay.S gesetzt sein,
F\_CPU, BAUD\_RATE und LOOP\_TICS. Die Konstante LOOP\_TICS muß auf die Anzahl
der Takte gesetzt sein, die von einer seriellen Bit-Ausgabe in der Schleife
gebraucht wird (normalerweise 9 Takte).
Für jede erzeugte Verzögerungsfunktion wird die Anzahl der Verzögerungstakte
in einer von vier verschiedenen Konstanten-Namen des C-Prozessors gespeichert,
BIT\_CLOCKS\_0, BIT\_CLOCKS\_1, BIT\_CLOCKS\_2 und  BIT\_CLOCKS\_3.
Bevor eine neue Verzögerungsschleife erzeugt wird, prüft der C-Preprozessor,
ob eine schon erzeugte Schleife zu den geforderten Parametern paßt.
Weil die Datei soft\_uart.S auch mit \#include eingefügt werden muß,
kann man diesen include auch mit anderen Parametern für eine andere
serielle Schnittstelle wiederholen. Aber man muß eine weitere Konstante
vorbesetzen, um die Namen der erzeugten Funktionen zu unterscheiden.
Wenn Sie die Konstante SOFT\_UART\_NUMBER vor dem \#include
auf 1 setzen (\#define SOFT\_UART\_NUMBER 1), wird die Funktion für die
serielle Eingabe getch\_1 und die Funktion für die serielle Ausgabe putch\_1 heißen.
Wenn man die Konstante NO\_SOFT\_UART\_TX vor dem \#include gesetzt hat,
wird keine serielle Ausgabefunktion generiert.
Gleiches gilt auch für die serielle Eingabe, wenn die Konstante NO\_SOFT\_UART\_RX
vor dem \#include gesetzt ist.

\subsection{Serielle Eingabe und Ausgabe über nur einen AVR Pin}

Manchmal ist es sinnvoll, die serielle Datenkommunikation nur über einen Pin zu betreiben,
um einen der wenigen IO-Pins bei kleinen AVRs freizuschalten. 
Mit einer speziellen Schaltungstechnik kann erreicht werden, daß in den Ausgabe-Pausen
der seriellen Ausgabe ein Einlesen von Daten möglich ist.
Bei der hier bei optiboot gewählten Software-Lösung ist ohnehin nur ein Halb-Duplex Betrieb
möglich. Es kann also zu einer Zeit nur entweder Daten gesendet oder Daten empfangen werden.
Normalerweise wird der Ausgabepin mit der TX-Funktion in den Sendepausen auf High Pegel
geschaltet, was ein Einlesen von Daten auf dem gleichen Pin verhindert.
Wenn aber der TX Ausgabepin statt auf den High Pegel in den Sendepausen auf den Eingabemodus
zurückgeschaltet wird, kann ein externer Pull-Up Widerstand den erforderlichen High Pegel
erzeugen.
Im Gegensatz zum festen High Pegel kann jetzt aber ein extern angeschlossenes TX-Signal
den Pegel für die serielle Einlesefunktion auf Low Pegel ziehen.
Ein serieller Widerstand in der Verbindung von dem gemeinsamen TX/RX Pin
des AVR mit dem TX Ausgang kann die Funktion des Pull-Up Widerstandes übernehmen,
da der Ruhezustand dieser Schnittstelle auf High Pegel liegt.
Außerdem sorgt dieser serielle Widerstand für eine Strombegrenzung,
falls doch einmal beide TX Schnittstellen gleichzeitig senden.
Damit die TX-Ausgabe des AVR von der externen seriellen Schnittstelle gelesen werden kann,
muß der RX-Eingang direkt mit dem gemeinsamen TX/RX verbunden werden.
Die Abbildung~\ref{fig:onewire-simple} soll die einfachste Verbindung veranschaulichen.

\begin{figure}[H]
\centering
\scalebox{1.0}{\includegraphics[]{../FIG/OneWire_simple.eps}}
\caption{Mögliche serielle Verbindung zum AVR mit einem Pin}
\label{fig:onewire-simple}
\end{figure}

Das Problem besteht nun darin, daß die meistens full-duplex fähige externe serielle Schnittstelle
die eigene Ausgabe zurückliest.
Darauf ist das Kommunikationsprogramm auf der externen Seite im allgemeinen nicht vorbereitet.
Es gibt nun die Möglichkeit, das Programm auf der externen Seite entsprechend anzupassen.
Ich halte das für keine gute Idee, da die angepasste Version dann entweder keine Wartung
mehr erhält oder es müßte die Änderung für neue Versionen ständig wiederholt werden.
Aus diesem Grund bevorzuge ich eine Hardware-Lösung.
Eine elektronische Schaltung, die zwischen die beiden Endpunkte der seriellen Schnittstelle
geschaltet wird, muß unterscheiden, ob die Daten von der externen Schnittstelle oder
von der AVR Seite gesendet werden.
Ein entsprechender Schaltungsvorschlag zeigt die Abbildung~\ref{fig:onewire}.

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire.eps}}
\caption{Schaltung zur Unterdrückung des Echos}
\label{fig:onewire}
\end{figure}

Mit den zwei ersten NAND Gattern des HCF4093 wird ein Flip-Flop gebildet,
welches von den zwei weiteren NAND Gattern dieses Bausteins
in den einen oder anderen Zustand geschaltet wird. Die Schaltsignale werden von
einer Kette von invertierenden Buffern mit Schmitt-Trigger Eingängen (HC7414) abgegriffen.
An einer Stelle ist ein zusätzliches C-R Glied (\(120 pF\) und \(3.3 k\Omega\) erforderlich,
um ein Schalten bei einer unerwünschten Flanke zu verhindern.
Umgeschaltet wird jeweils mit einer 1-0 Flanke der beiden Sendeseiten.
Erforderlich ist diese Umschaltung nur bei der Flanke des Startbits.
Aber ein zusätzliches Schalten durch Datenbits schadet nicht, wenn das Flip-Flop schon im
richtigen Zustand ist. Wenn die externe Schnittstelle sendet, wird der Empfang der
Daten über den externen Empfänger verhindert. Das externe RX-Signal bleibt auf High Pegel.
Mit dieser Zusatzschaltung ist keine Software-Anpassung notwendig. Für den
Bootloader kann zum Beispiel das avrdude Programm benutzt werden.
Die Schaltung ist weitgehend unabhängig von der benutzen Baudrate.
Lediglich bei sehr hohen Baud-Raten erwarte ich Probleme. Bei 115200 Baud läuft die Schaltung
aber einwandfrei. Sehr viel höhere Baudraten sind bei der Softwarelösung sowieso
oft nicht möglich.

\subsection{Benutzung der automatischen Baudraten-Bestimmung}
\label{sec:autobaud}

Wenn für die Erzeugung des Bootloaders eine Baudrate unter \(100Baud\)
angegeben wird, wird die Baudrate aus dem ersten empfangenen Zeichen
automatisch ermittelt.
Zum Beginn einer Übertragung mit dem STK500 Protokoll sendet der Rechner
das Kommando STK\_GET\_SYNC (0x30) gefolgt vom Steuerzeichen CRC\_EOP (0x20).
Bei der seriellen Übertragung ist als Ruhezustand der High-Pegel (1)
verabredet. Die Übertragung beginnt dann mit einen Start-Bit auf Low-Pegel (0).
Unmittelbar darauf wird die verabredete Zahl der Datenbits (8) beginnend
mit dem niederwertigsten Bit übertragen und dann die Übertragung mit einem oder
mehreren Stop-Bit (1) abgeschlossen. 
Der Pegel jedes einzelnen Bits wird für die verabredete Baud-Zeit beibehalten.
Unmittelbar nach dem Ende der Stop-Bit Übertragung kann das nächste Start-Bit
folgen. Es kann aber auch eine Pause mit nicht definierter Zeit bis zur 
Übertragung der nächsten Bitfolge auf das Stop-Bit folgen. 
In der Abbildung \ref{fig:AutoBaud} ist das erwartete Ergebnis für die möglichen
Zeitmessungen dargestellt. Auf der Zeitachse ,,t'' sind vier mögliche Startpositionen
für eine vollständige Zeitmessung dargestellt. Der Counter wird jeweils
bei einer erkannten 1 - 0 Flanke gestartet. Die richtige Startposition
für das STK\_GET\_SYNC Zeichen ist mit der ,,1'' markiert.
Die Marken ,,2'', ,,3'' und ,,4'' zeigen die Situation für drei falsche Startpositionen.
Bei der Marke ,,2'' und ,,4'' wird fälschlicherweise eine 1-0 Flanke in der
Datenübertragung als Start-Bit angenommen. Bei der Marke ,,3'' wird zwar
ein Start-Bit richtig erkannt, es ist aber das falsche Zeichen (CRC\_EOP).
Es können immer dann die falschen Start-Bits erkannt werden, wenn der Bootloader
erst gestartet wird, wenn die Datenübertragung schon läuft.
In der Abbildung~\ref{fig:AutoBaud} sind die erwarteten Zählerstände für die
4 möglichen Startfälle angegeben. Dabei bedeutet das ,,b'' den Zählerstand
für ein Bit (Baud-Dauer), das ,,d'' steht für eine mögliche Zeitverzögerung
zwischen dem Ende der Stopbit-Übertragung bis zum Beginn eines neuen Startbits.
Das ,,D'' steht für eine zu erwartende lange Zeitverzögerung bis zum nächsten
Startbit. Die Sendesequenz ist hier zu Ende und der Rechner wartet auf eine
Antwort des AVRs.
In der Rx-Reihe sind die Datenbits von ,,0'' (kleinstes Bit) bis ,,7'' (höchstes Bit)
nummeriert. Das Start-Bit ist mit ,,A'' und das Stop-Bit mit ,,E'' gekennzeichnet.
Das este Byte ist die Codierung des STK\_GET\_SYNC Kommandos und das zweite Byte
die Kodierung des Steuerzeichen CRC\_EOP.


\begin{figure}[H]
\centering
\scalebox{0.55}{\includegraphics[]{../FIG/AutoBaud.eps}}
\caption{Mögliche Zeitmessungen für die STK\_GET\_SYNC Bitfolge}
\label{fig:AutoBaud}
\end{figure}

\begin{itemize}

\item {Einfachste Form der Baudraten Messung, BAUD\_RATE \textless~30}

Die einfachste Form der Baudraten-Messung beachtet die Möglichkeit der
falschen Startbit Wahl überhaupt nicht. Es wird fest davon ausgegangen,
daß das erkannt Startbit zum STK\_\-GET\_\-SYNC Zeichen gehört.
Nach der Startbit Erkennung wird bis zur nächsten 0-1 Flanke gewartet
und dann ein 16-Bit Zähler mit der Frequenz F\_CPU/8 bei -1 gestartet.
Wenn die Einerstelle der Baudrate größer als 5 ist, wird der
16-Bit Zähler mit der F\_CPU Frequenz gestartet.
Bei der darauf folgenden 1-0 Flanke wird der Zählerstand abgelesen
und halbiert als Frequenzteiler des UARTs genommen.
Die Halbierung ist notwendig, weil die Zeit von 2 Datenbits gemessen wurde.
Eigentlich muß noch 1 vom Ergebnis für den Frequenzteiler abgezogen werden.
Aber bei der Halbierung sollte gerundet werden, also 1 auf den Zählerstand
addiert werden. Anstelle der Subtraktion der 1 vom Divisions-Ergebnis kann
man auch 2 vom Zählerstand subtrahieren. 
Die Methode funktioniert ausreichend gut,
wenn automatisch kurz vor dem Übertragungs-Start ein Reset des AVRs und damit
ein Neustart des Bootloaders ausgelöst wird. Dies ist dann der Fall,
wenn das DTR (Data Terminal Ready) Signal für die Erzeugung eines Reset-Signals
benutzt wird.
Man kann auch ohne das automatisch generierte Reset-Signal erfolgreich sein,
wenn eine Reset-Taste am AVR angeschlossen ist, die solange gedrückt gehalten
wird, bis das Übertragungsprogramm gestartet ist. Hier ist aber etwas
Gefühl für den richtigen Loslass-Zeitpunkt des Tasters erforderlich.
Das Bootloader-Programm wartet nur maximal die Zeit auf den Beginn der Übertragung,
die über der Watchdog-Timer vorgegeben ist.
Wenn der Watchdog-Timer einen Reset auslöst, wird normalerweise das Anwenderprogramm
gestartet. Nur wenn noch kein Anwenderprogramm geladen wurde,
startet der Bootloader erneut und versucht es noch einmal.

\item {Verbesserte Form der Baudraten Messung, BAUD\_RATE \textless~40}

Wie bei der einfachsten Form der Baudraten-Messung wird hier auf eine Prüfung
der Bit-Wechselzeiten verzichet.
Es wird nur weiter auf die nächste 0-1 Flanke des RX-Signals
gewartet und erst dann der Zähler gelesen.
Dadurch wird die Zeit von vier Datenbits gemessen, die dann für die Berechnung
der Baudrate verwendet wird.
Da die Zeiterfassung durch die Abfrage-Schleife (polling) unpräzise ist,
wirkt dieser mögliche Zeitfehler weniger, wenn er durch vier statt durch
zwei geteilt wird.  
Daher sollte diese Form immer dann gewählt werden, wenn es auf wenig Speicherbelegung
ankommt. Gegenüber der einfachsten Form werden nur 4 Byte mehr belegt.

\item {Einfachste Form der Baudraten Messung mit Zeitüberwachung, BAUD\_RATE \textless~50}

Hier wird die gleiche Methode der Baudraten-Bestimmung angewendet, wie bei
der einfachsten Form. 
Nur wird das mögliche Überlauf-Ereignis des Zählers zusätzlich
überwacht, was die Abfrage-Schleifezusätzlich verlangsamt.
Durch den längeren Schleifen-Zyklus wird die Zeitmessung weniger exakt als
bei der Methode ohne Zeitüberwachung zu erwarten ist.
Daher ist diese Version nicht bei der Verwendung hoher Baudraten zu empfehlen.
Bei dem Überlauf-Ereignis wird sofort mit der Suche nach einem neuen RX-Start-Bit
begonnen.
Ohne diese Begrenzung würde das Programm in der
Schleife verweilen, bis entweder ein Start-Bit entdeckt wird oder 
die Schleife durch einen Reset vom Watchdog-Timer abgebrochen wird.
Wahrscheinlich wird dadurch das Problem mit der Start-Position ,,4'' im
Diagramm~\ref{fig:AutoBaud} etwas verbessert.
Aber auch der Neustart der Start-Bit Suche würde einen Reset vom Watchdog-Timer
nur geringfügig verzögern. Bei der Suche nach dem Start-Bit darf der
Watchdog-Timer nicht zurückgesetzt werden, weil sonst kein Anwenderprogramm
mehr gestartet würde. Deshalb muß die Zeit für den Watchdog-Timer größer
sein als die Zeit bis zur Wiederholung der STK\_GET\_SYNC Sequenz
ohne eine Antwort auf die vorausgehende STK\_GET\_SYNC Sequenz.

\item {Verbesserte Form der Baudraten Messung mit Zeitüberwachung, BAUD\_RATE \textless~60}

Die Messung der Baudrate erfolgt genau so wie bei der verbesserten Methode (\textless~40).
Nur wird wie bei der Methode \textless~50 beschrieben zusätzlich eine
Begrenzung der Wartezeit durchgeführt.
Weil der Zählerstand erst bei der 0-1 Flanke gelesen wird und da der Zählerüberlauf
nur bei der 1-0 Flanke geprüft wird, ist die Zeit genau so inexakt wie
bei der verbesserten Methode ohne die Zeitüberwachung.

\item {Aufwendige Form der Baudraten Messung, BAUD\_RATE \textless~80}

Bei dieser Methode wird der Zähler mit der Erkennung eines Start-Bits
sofort bei 0 gestartet und bei den folgenden 3 Bitwechseln der Zählerstand
abgelesen. Dadurch ist die Zeitfolge der Bitwechsel für das STK\_GET\_SYNC
Zeichen vollständig bekannt.
Vom Programm wird die Zeitfolge auf Plausibilität geprüft.
Als erster Test wird geprüft, ob die Differenz zwischen der 3. Zählerlesung
und der ersten Zählerlesung kleiner ist als die erste Zählerlesung.
Für den richtigen Startpunkt ,,1'' ist das der Fall ((9b - 5b) < 5b).
Für den falschen Startpunkt ,,3'' ist das aber leider auch der Fall
((9b - 6b) < 6b). 
Mit großer Wahrscheinlichkeit ist das für den Startpunkt ,,3'' aber nicht der
Fall ((9b -3b) < (3b+d)), wenn die Zeitverzögerung des zweiten Startbits ,,d''
hinreichend klein ist. 
Für den falschen Startpunkt ,,4'' hilft ohnehin nur eine Zeitüberwachung beim
Warten auf den 2. Bitwechsel, da die Wiederholung der STK\_GET\_SYNC Sequenz
erst nach längerer Wartezeit (,,D'') auf die Antwort erfolgt.
Mit einem zweiten Test wird geprüft, ob die Differenz zwischen der 3.
Zählerlesung und der 2. Zählerlesung nicht deutlich größer ist als
die Differenz zwischen der 2. Zählerlesung und der ersten.
Für den richtigen Startpunkt ,,1'' ergibt sich folgender Vergleich:
((9b-7b) < (7b-5b+4)) oder (2b < 2b+4).
Für den falschen Startpunkt ,,2'' sieht der Vergleich so aus:
((9b-3b) < (3b+d-2b+4)) oder (6b < (b+d+4)).
Für den falschen Startpunkt ,,3'' ergibt sich der Vergleich so:
((9b-7b) < (7b-6b+4)) oder (2b < (b+4)).
Diese Prüfungen sind relativ sicher, erfordern aber auch relativ viel
zusätzlichen Speicherplatz für das Programm. Diese Methode ist
besonders dann zu empfehlen, wenn ohnehin mindestens 1024 Byte für den Bootloader
reserviert sind (Bootloader Page Size).
Für die Berechnung des UART Frequenzteilers wird die Differenz der
3. Zählerlesung und der 2. Zählerlesung halbiert (9b-7b-1)/2 = (2b+1)/2-1.

\item {Aufwendige Form der Baudraten Messung, BAUD\_RATE \textless~100}

Alle Zeitlesungen und Kontrollen werden wie bei der Methode mit
Baud\_RATE \textless~80) durchgeführt. Lediglich für die Berechnung
des UART Frequenzteilers wird die Zeit von 4 Bits benutzt.
Somit ergibt sich für den richtigen Startpunkt ,,1'' die folgende
Berechnung (9b-5b-2)/4 = (4b+2)/4-1.

\end{itemize}

Für alle Methoden der Baudraten-Bestimmung würde ich die Zusatzfunktion des
LED-Blinkens weglassen, um die Erkennung des Start-Bits nicht zu verzögern.
Leider braucht auch die simpelste Form der Baudraten-Messung so viel
Programmspeicher, daß der Bootloader nicht in 512 Byte Flash passt,
wenn zusammen mit der EEprom-Unterstützung (SUPPORT\_EEPROM=1) auch
das LED-Blinken gewählt wird.
Bei einigen Prozessoren kann als Zusatzfunktion noch die LED\_DATA\_FLASH
gewählt werden ohne die 512 Byte Grenze zu überschreiten. 
Wenn die Grenze von 512 Byte wegen benötigter Funktionen ohnehin überschritten
wird, sind auch mit der Baudratenmessung alle Funktionen im Prinzip
wieder möglich. 
Zusammen mit der SOFT\_UART Funktion kann die Baudratenbestimmung nur mit
der Assembler-Version des Optiboot Programms benutzt werden.
Die C-Variante unterstützt die Baudratenmessung mit der automatischen Einstellung
der Baudrate nur für einen Hardware-UART.

Bei der Baudratenmessung für die Software UART Funktion bestehen einige Unterschiede
und Besonderheiten gegenüber der Lösungen für die Hardware UART Schnittstelle.
Normalerweise  für wird für die halbe Baud-Zeit ein 8-Bit Zähler in einer
Verzögerungsschleife benutzt. Mit diesem Zähler kann die Anzahl der CPU-Takte für die
Verzögerung wegen der Schleifen-Durchlaufzeit nur auf 3 Takte genau eingestellt werden. 
Wegen des doppelten Aufrufs der Schleife für die volle Baud-Zeit muß man 
die Auflösung ebenfalls verdoppeln.. Bei einer fest gewählten
Baudrate wird der dadurch entstehende Fehler im Programm ausgeglichen. 
Das ist hier nicht möglich, da die Baudrate ja nicht im voraus bekannt ist.
Um auf jeden Fall die bestmögliche Rundung des eingestellten Wertes zu ermöglichen,
wird für die Zeitmessung der Zähler bei der vollen CPU-Taktrate (F\_CPU) betrieben.
Für den Hardware-UART reicht für den Zähler ein Betrieb mit F\_CPU/8.

Bedingt durch den 8-Bit Zähler ergibt sich abhängig von der CPU-Taktrate
eine maximale Verzögerungszeit und damit eine Mindest-Baudrate, die
deutlich höher ist als die Mindest-Baudrate für den Hardware-UART.
Durch die beschränkte Auflösung der Perioden-Einstellung für
die Baudrate ergibt sich auch eine obere Baudrate, für die ein Fehler von 
kleiner als 4\% garantiert werden kann.
Bei Betrieb des AVR mit einem RC-Generator ist oft die Taktrate selbst schon
fehlerbehaftet. Bei der Messung der Baudrate ist dieser Fehler dann
schon vom Zähler berücksichtigt, der Fehler durch die beschränkte Einstellmöglichkeit
ist dann aber nicht im voraus berechenbar.
An einem Beispiel für den Hardware-UART  möchte ich zeigen, was ich damit meine.
Die Baudrate von \(250kHz\) ist bei einer Taktrate von genau \(8MHz\) benutzbar.
Dazu wird der Teiler für die Baudraten-Erzeugung auf 32=4*8 eingestellt, wobei sich 
dann kein Fehler ergibt.
Wenn ich nun eine abweichende Taktrate von \(7.6MHz\) annehme, ist
der bestmögliche Teiler ebenfalls 32. Dadurch ergibt sich die Baudrate mit
dem gleichen Fehler wie die Taktrate von \(237.5kHz\), in beiden Fällen sind es -5\%.
Um wenigstens die untere Baud-Grenze mit der Software-UART Lösung überwinden
zu können, wird bei allen vorgegebenen Baud-Werten unter 100, die ungerade sind
eine Verzögerungsschleife mit 15-Bit benutzt. Leider beträgt dann die Durchlaufzeit
der Schleife dann 5 Takte. Durch den doppelten Aufruf der Verzögerungsschleife beträgt
die Auflösung nur noch 10 Takte und damit etwas schlechter als die Hardware-UART
Lösung durch den 8:1 Vorteiler.
Daher sollte man diese Option nur dann benutzen, wenn man keine sehr hohen Baudraten benutzen möchte.
Die folgende Tabelle~\ref{tab:AutoBaud8} soll den Einsatzbereich der verschiedenen Optionen
bei der Betriebsfrequenz \(8MHz\) zeigen.
In der Tabelle ist der Zeit-Fehler nicht berücksichtigt, der bei der Messung der Baudrate
durch die Abfrageschleife des RX-Signals entstehen kann.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
   BAUD\_RATE  & SOFT\_ & Minimum & BAUD-Err & Kommentar  \\
   Option      & UART   & Baud    & \textless 4\% @ Baud &  \\
    \hline
    \hline
    40-99      &  0     &  1949       &   80.0k  & HW\_UART  \\
    \hline
    42         &  1     &  5151       &   81.6k  & Simple, 2-Bit Time, 8-Bit Delay  \\
    \hline
    62         &  1     &  5151       &   81.6k  & Complex, 2-Bit Time, 8-Bit Delay  \\
    \hline
    82         &  1     &  5151       &   81.6k  & Complex, 4-Bit Time, 8-Bit Delay  \\
    \hline
    43         &  1     &  244       &   53.3k  &  Simple, 2-Bit Time, 15-Bit Delay\\
    \hline
    63         &  1     &  1220       &   53.3k &  Complex, 2-Bit Time, 15-Bit Delay \\
    \hline
    83         &  1     &  1220       &   53.3k & Complex, 4-Bit Time, 15-Bit Delay \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Grenzen für die automatische Baudrate bei 8MHz Takt.}
  \label{tab:AutoBaud8}
\end{table}

Für die Fehlergrenze von 2\%, die normalerweise als Grenze für das Gelingen
angenommen wird, ist angenommen worden, daß beide Gegenstellen einen Fehler
in unterschiedlicher Richtung haben können. Da bei der Autobaud-Funktion
der Fehler der Gegenstelle mit gemessen wird, kann man hier eine doppelte
Obergrenze für den Fehler von 4\% annehmen.
Bei Benutzung der Hardware-UART Schnittstelle sind unabhängig der gewählten
Option für die Messung die Standard Baudraten 1200, 2400, 4800, 9600, 19200,
38400 und 57600 benutzbar.
Höhere Baudraten sind nicht mehr sicher bei der Benutzung, obwohl
auch \(115.6kBaud\) bei Tests oft funktionierte.
Ebenso war ein Test mit 115.2 kBaud bei \(16 MHz\) Quarz-Betrieb erfolgreich,
selbst bei Benutzung der Software UART Lösung mit der 15-Bit Verzögerungsschleife.
Wenn für die Software-UART Lösung die 8-Bit Verzögerungsschleife benutzt wird,
kann die Baudrate 1200, 2400 und 4800 nicht benutzt werden.
Erst bei Benutzung der 15-Bit Verzögerungsschleife sind die unteren Baudraten
mit Software UART benutzbar.
Der Unterschied zwischen der 49 und der 69 bzw. 89 Einstellung ergibt
sich durch den verwendeten 16-Bit Zähler. Bei der Einstellung 49 wird nur
die Zeit von 2 Datenbits gemessen, bei den Einstellungen über 59 wird
die komplette Byte-Sequenz vom Start-Bit bis zum Stop-Bit mit dem 16-Bit Zähler gemessen.
Baudraten unter 9600 Baud werden wahrscheinlich aber ohnehin eher selten benutzt.
Die Bereiche für die Baudrate verschieben sich natürlich mit der verwendeten
Taktrate für den Prozessor.

Abschließend möchte ich die Ergebnisse von Tests mit einen ATmega1281 bei etwa \(8MHz\)
RC-Oszillator Frequenz vorstellen, die ich bei und oberhalb der garantierten Baudrate
durchgeführt habe. Die Frequenz des RC-Generators habe ich dabei mit der
OSCCAL\_CORR Option in 2er Schritten verstimmt und jeweils gemessen.
Mit der Software UART Lösung gelangen alle Tests, ein kleines Anwenderprogramm
zu laden. Weil die Ergebnisse bei der Baudrate 57600
so ermutigend waren, habe ich zusätzlich die Tabelle um Tests bei 115200 Baud
ergänzt. 

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c || c | c | c || c | c | c |}
    \hline
   OSCCAL  & Freq. & HW-UART & \multicolumn{2}{c ||}{SW-UART} & HW-UART & \multicolumn{2}{c |}{SW-UART} \\
   \_CORR  & kHz       & 57600   & \multicolumn{2}{c ||}{57600}  & 115200  & \multicolumn{2}{c |}{115200}  \\
           &           & Mode 82 & Mode 82 & Mode 83 & Mode 56 & Mode 52 & Mode 53 \\
    \hline
    \hline
    20     &  7157   &  OK       &   OK    &   OK    &  Err    &  Err    &   Err \\
    18     &  7217   &  OK       &   OK    &   OK    &  Err    &  Err    &   Err \\
    \hline
    16     &  7318   &  OK       &   OK    &   OK    &  OK     &  OK     &   Err \\
    14     &  7404   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
    \hline
    12     &  7521   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
    10     &  7591   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
    \hline
     8     &  7710   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
     6     &  7815   &  OK       &   OK    &   OK    &  Err    &  OK     &   OK  \\
    \hline
     4     &  7933   &  OK       &   OK    &   OK    &  Err    &  Err    &   Err \\
     2     &  8012   &  OK       &   OK    &   OK    &  Err    &  OK     &   Err \\
    \hline
     0     &  8141   &  OK       &   OK    &   OK    &  Err    &  OK     &   Err \\
    -2     &  8247   &  OK       &   OK    &   OK    &  OK     &  OK     &   Err \\
    \hline
    -4     &  8390   &  OK       &   OK    &   OK    &  OK     &  OK     &   Err \\
    -6     &  8485   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
    \hline
    -8     &  8623   &  OK       &   OK    &   OK    &  OK     &  Err    &   OK  \\
    -10    &  8745   &  OK       &   OK    &   OK    &  OK     &  OK     &   OK  \\
    -12    &  8889   &  OK       &   OK    &   OK    &  Err    &  OK     &   OK  \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Test für die automatische Baudrate bei 8MHz Takt.}
  \label{tab:AutoBaudTest8}
\end{table}


Für den Betriebsmodus 82 habe ich mit dem Software UART
auch die ungeraden OSCCAL\_CORR Einstellungen ohne erkennbare Schwierigkeiten geprüft.
Auch mit dem einfachsten Betriebsmodus 42 waren bei den geraden OSCCAL\_CORR
Einstellungen der Tabelle keine Ausfälle zu verzeichnen.
Erst bei der für diese CPU-Frequenz extrem hohen Baudrate von \(115.2k\) waren 
für den Betriebsmodus 52 vier Ausfälle und mit dem Betriebsmodus 53 acht Ausfälle
zu beobachten. Die Zunahme der Ausfälle bei Betriebsart 53 mit der 15-Bit Zeitschleife war
wegen der groberen Rasterung der einstellbaren Zeiten zu erwarten.

Ein Test mit einer chinesischen Arduino UNO Platine, die als USB-seriell Wandler einen
CH340G Chip verwendet, lief übrigens nur bis 38400 Baud einwandfrei.
Bei höheren Baudraten machte das Zurücklesen der Programmdaten Probleme.
Wahrscheinlich wird das letzte Byte eines Datenpakets nicht zum Rechner übertragen und
die Kommunikation bleibt hängen. Bei einer Arduino UNO Platine mit Mega16U2 Controller
als USB-seriell Wandler trat das Problem nicht auf. Mit dieser Platine war sogar
ein Betrieb der seriellen Schnittstelle bei \(230.4kBaud\) möglich, wahrscheinlich
weil sowohl der ATmega328p als auch der Mega16U2 die gleiche tatsächliche Baudrate
von \(250kBaud\) benutzen.


\section{Einige Beispiele für die Erzeugung eines optiboot Bootloaders}

Das erste Beispiel ist die Bildung eines Bootloaders für den beliebten ATmega328P:

\begin{verbatim}
optiboot $ make atmega328p
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
In file included from optiboot.S:612:0:
init_uart_fix_baud.S:31:8: warning: #warning "BAUD_RATE error greater than 2%" [-Wcpp]
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Error=2.12%
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    476	      0	      0	    476	    1dc	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
   -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Wenn keine zusätzliche Option angegeben wird, wird eine Baudrate von 115200 mit einer Taktfrequenz von \(16 MHz\) gewählt.
Für die serielle Ausgabe wird die vorhandene Hardware-Schnittstelle benutzt. 
Man beachte, daß der systematische Fehler der Baudrate über 2\% mit dem Hardware UART beträgt.
Das zweite Beispiel zeigt die Erzeugung von optiboot für den gleichen Prozessor mit einer Software-Lösung
für die serielle Schnittstelle.

\begin{verbatim}
optiboot $ make atmega328p SOFT_UART=1
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=01 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
pin_defs.h:206:6: warning: #warning "SOFT_UART use Pin D0 as RX" [-Wcpp]
pin_defs.h:216:6: warning: #warning "SOFT_UART use Pin D1 as TX" [-Wcpp]
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  SoftUART_Real: 115107, Delay: 116*1, Error=-.07%
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    496	      0	      0	    496	    1f0	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
   -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Beachten Sie bitte, daß die Software-Lösung für die serielle Schnittstelle etwas mehr flash-Speicher braucht,
aber es wird auch nur eine ,,boot page'' gebraucht. Der systematische Fehler der Baudrate ist hier deutlich kleiner
wie bei dem Hardware-UART.
Aber der Hardware-UART hat den Vorteil, daß Eingang und Ausgang gleichzeitig bearbeitet werden kann (full duplex) und 
außerdem ist die Hardware-Lösung fehlertoleranter gegenüber kurzen Störungen des Eingangssignals.
Für die serielle Schnittstelle mit Software kann jeder digitale IO-Pin als Eingang (UART\_RX) und als Ausgang (UART\_TX)
gewählt werden. In diesem Beispiel wird die Fähigkeit benutzt, automatisch die IO-Pins des Hardware-UART's zu wählen.
Die drei ,,warning'' Meldungen, die Sie über diese automatische Wahl informieren, können Sie ignorieren.
Die automatische Wahl der IO-Pins hängt vom gewählten Prozessor-Typ und von der gewählten UART Nummer ab,
wenn mehr als ein UART zur Verfügung steht.

Die letzten beiden Beispiele zeigen jeweils eine Konfiguration mit der neuen automatischen Anpassung der Baudrate.
Um Platz im Speicher zu sparen, wurde beim ersten Beispiel die LED-Blinkfunktion abgewählt.

\begin{verbatim}
optiboot $ make atmega328p LED_START_FLASHES=0 BAUD_RATE=52
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=52 -DLED_START_FLASHES=0 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
--------------------------------------------------------------------------------
Simple Baudrate measurement with time limit implemented in optiboot! (4-bit, CLK/8)
UART Minimum 976 Baud, Error surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7E00 = 32256
###########################################

16000000 Hz operation with Auto-Baudrate configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    498	      0	      0	    498	    1f2	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Beim letzten Beispiel wurde die aufwendigste Methode der Baudraten-Messung
gewählt, da mit der LED-Blink Funktion ohnehin die Grenze von 512 Byte
überschritten würde (534 Bytes).

\begin{verbatim}
optiboot $ make atmega328p BAUD_RATE=82
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=82 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=0 -DSOFT_UART=0 \
        -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 \
        -DHFUSE=hexDE -DLFUSE=hexFF \
        -DBOOT_PAGE_LEN=512 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:195:5: warning: #warning "LED bit is set to default B5" [-Wcpp]
--------------------------------------------------------------------------------
Complex Baudrate measurement implemented in optiboot! (4-bit, CLK/8)
UART Minimum 488 Baud, Error surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
###########################################
Boot Loader start address: 0x7C00 = 31744
###########################################

16000000 Hz operation with Auto-Baudrate configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    596	      0	      0	    596	    254	optiboot.elf
Requires 2 Boot Pages, 512 Bytes each
BOOTSZ=2
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}


\section{Anpassung der Taktfrequenz bei internem RC-Generator}

Die Benutzung der seriellen Schnittstelle ist nur möglich, wenn die eingestellte Baudrate
hinreichend genau eingehalten wird. Die tatsächliche Baudrate hängt unmittelbar von dem tatsächlichen
Prozessortakt und von dem berücksichtigtem Teilerverhältnis für die Takt der seriellen Ein-Ausgabe ab.
Die Hardware UART Schnittstelle teilt den Prozessortakt generell durch 8 oder durch 16 und kann
dann für den bereits vorgeteilten Takt einen weiteren einstellbaren Teiler zwischen 1:1 und 1:4096  
zur Erzeugung des Taktes für die serielle Schnittstelle benutzen. Für niedrige Baudraten kann der
Prozessortakt bei Bedarf noch um zusätzliche 2er Potenzen geteilt werden.
Wenn das Verhältnis zwischen dem Prozessortakt zu dem Baudraten-Takt ausreichend hoch ist, kann damit
die Baudrate ausreichend genau eingestellt werden. Bei der Erzeugung des Optiboot Bootloaders
wird der systematische Fehler dieser Erzeugung protokolliert.
Normalerweise sind Fehler von weniger als 2\%  als unkritisch anzusehen.
Für die Implementation der seriellen Schnittstelle mit Software (SOFT\_UART) werden meistens geringere
systematische Fehler der Baudrate erreicht. Hier liegen die Schwierigkeiten bei der fehlenden
Fehlerunterdrückung der Einlese-Funktion und bei der mangelden Fähigkeit, die Schnittstelle
,,voll duplex'' zu betreiben. Von der Ausgabe des letzten Bits bis zur Empfangsbereitschaft vergeht immer
eine gewisse Zeit. Daher ist hier bei geringeren Baudraten mit weniger Schwierigkeiten zu rechnen.

Alle diese Betrachtungen setzen aber voraus, daß der Prozessortakt selbst hinreichend genau eingehalten wird.
Bei Quarz oder Keramik-Resonator Betrieb ist das meistens ohne weitere Maßnahmen der Fall.
Anders sieht das aber bei der Benutzung des internen RC-Generators der AVR Prozessoren aus.
Hier kann die Prozessorfrequenz deutlich vom Wunschwert abweichen. Die Prozessoren sind zwar ab Werk
vorkalibriert. Dies gilt aber oft nur für eine Frequenz und für eine Temperatur und eine Betriebsspannung.
Je nach Prozessortyp ist die Frequenz des RC-Generators mehr oder weniger abhängig von Temperatur
und Betriebsspannung.

Um vorhandene Fehler der Frequenz mit dem internen RC-Generators ausgleichen zu können,
wird der Kalibrationswert des Herstellers beim Start des Prozessors in das IO-Register OSCCAL kopiert.
Der Optiboot Bootloader kann die Option OSCCAL\_CORR benutzen, um den vorhandenen Restfehler
auszugleichen.

Wenn die aktuelle Taktrate für Ihre Applikation unwichtig ist und
Sie mehr Speicherplatz für den Bootloader zur Verfügung stellen können,
können Sie auch die automatische Baudraten-Anpassung von Optiboot benutzen.
Die automatische Baudraten-Anpassung wird immer dann eingebaut,
wenn Sie bei der Erzeugung eine Baudrate unter 100 angeben.
Näheres zur automatischen Baudraten-Anpassung finden Sie
im Unterkapitel~\ref{sec:autobaud} aud Seite~\pageref{sec:autobaud}.

In den folgenden Unterkapiteln werde ich einige AVR-Typen exemplarisch näher untersuchen.

\subsection{Untersuchung der RC-Generatoren des ATmega8}

Der ATmega8 kann 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, \(1MHz\), \(2MHz\), \(4MHz\) und \(8MHz\).
In der Tabelle \ref{tab:mega8freq} habe ich alle 4 Frequenzeinstellungen untersucht.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
   FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
      1M & 0xA1  &  9.6k &  -8  & 1050k &  4  & 983k  & 0  & 1004k \\
    \hline
      2M & 0xA2  & 19.2k &  -8  & 2098k &  4  & 1967k & 0  & 2008k \\
    \hline
      4M & 0xA3  & 19.2k &  -2  & 4201k & 10  & 3927k & 7  & 3999k \\
    \hline
      8M & 0xA4  & 57.6k &   0  & 8231k & 13  & 7723k & 6  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega8}
  \label{tab:mega8freq}
\end{table}

Die Tabelle \ref{tab:mega8freq} zeigt, daß für den 1Mhz und 2MHz Betrieb eine Korrektur des
OSCCAL Registers nicht erforderlich ist. Dieser ATmega8 ist ab Werk für diese Frequenzen sehr gut kalibriert.
Bei \(4MHz\) kommt man noch ohne Korrektur aus, erreicht aber bei OSCCAL\_CORR=7 die richtige
Schwingfrequenz. Bei \(8MHz\) ist der Betrieb der seriellen Schnittstelle so gerade eben
noch möglich, sicherer läuft die serielle Schnittstelle aber mit OSCCAL\_CORR=6.

\subsection{Untersuchung der RC-Generatoren des ATmega8535}

Der ATmega8535 kann wie der ATmega8 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, \(1MHz\), \(2MHz\), \(4MHz\) und \(8MHz\).
In der Tabelle \ref{tab:mega8535freq} sind die Ergebnisse bei einem Exemplar für
 alle 4 Frequenzeinstellungen festgehalten.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
  AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  3  & 982k  & 0  & 1001k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2095k &  4  & 1965k & 1  & 1998k \\
    \hline
                4M & 0xA3  & 19.2k &  -5  & 4204k &  8  & 3932k & 4  & 4012k \\
    \hline
                8M & 0xA4  & 19.2k &  -7  & 8420k &  6  & 7901k & 3  & 8003k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega8535}
  \label{tab:mega8535freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren des ATmega8515 und des ATmega162}

Der ATmega8515 kann wie der ATmega8 4 verschiedene Frequenzen
mit dem internen RC-Generator
über die Low-Fuse einstellen, \(1MHz\), \(2MHz\), \(4MHz\) und \(8MHz\).
In der Tabelle \ref{tab:mega8515freq} sind die Ergebnisse bei einem Exemplar für
 alle 4 Frequenzeinstellungen festgehalten.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
  AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  2  & 985k  & -1  & 997k \\
    \hline
                2M & 0xA2  & 19.2k &  -10  & 2099k &  3  & 1963k & -1  & 1999k \\
    \hline
                4M & 0xA3  & 38.4k &  -3  & 4192k &  10  & 3928k & 7  & 3979k \\
    \hline
                8M & 0xA4  & 38.4k &  -3  & 8396k &  10  & 7860k & 7  & 7966k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega8515}
  \label{tab:mega8515freq}
\end{table}

Mit einer ähnlichen Pinbelegung aber nur einem \(8MHz\) RC-Generator liefert
ein ATmega162 die Ergebnisse von Tabelle~\ref{tab:mega162freq}.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
  AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                8M & 0xE2  & 38.4k &  0  & 8190k &   6  & 7718k & 2  & 8000k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für den RC-Oszillator des ATmega162}
  \label{tab:mega162freq}
\end{table}


\subsection{Untersuchung der RC-Generatoren der ATmega328 Familie}

Bei der ATmega328 Familie kann nur eine RC-Oszillatorfrequenz von \(8MHz\) gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein \(1MHz\) Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega328freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega48P &          8M & 0xE2  & 57.6k &  -6  & 8230k &  8  & 7720k  & 0  & 8010k \\
    \hline
mega88 &          8M & 0xE2  & 57.6k &  -2  & 8250k & 10  & 7770k  & 4  & 7990k \\
    \hline
mega168 &          8M & 0xE2  & 57.6k &  -5  & 8263k &  8  & 7720k  & 1  & 7970k \\
    \hline
mega328P &          8M & 0xE2  & 57.6k &  -5  & 8250k &  9  & 7723k  & 1  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega328 Familie}
  \label{tab:mega328freq}
\end{table}

Bei allen untersuchten Prozessoren ist ein Betrieb der seriellen Schnittstelle 
auch mit dem internen RC-Oszillator möglich. Nur bei dem untersuchten ATmega88 
würde sich bei OSCCAL\_CORR=4 eine Korrektur überhaupt lohnen.

\subsection{Untersuchung der RC-Generatoren des ATmega32 / 16}

Der ATmega32 und der ATmega16 können 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, \(1MHz\), \(2MHz\), \(4MHz\) und \(8MHz\).
In den Tabellen \ref{tab:mega32freq} und \ref{tab:mega16freq} habe ich alle 
4 Frequenzeinstellungen untersucht.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c || c | c || c | c || c | c |}
    \hline
       & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
 Typ    &     FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
m32  &       1M    & 0xA1  &  9.6k &  -13  & 1049k & -1  & 980k  & -5  & 1001k \\
m32a &             &       &       &  -7  & 1046k &  4  & 984k  & 1  & 998k \\
    \hline
m32  &       2M    & 0xA2  & 19.2k &  -12  & 2102k &  0  & 1968k & -3  & 1997k \\
m32a &             &       &       &  -7  & 2105k &  6  & 1966k & 2  & 2005k \\
    \hline
m32  &       4M    & 0xA3  & 19.2k &  -5  & 4169k & 6  & 3942k & 3  & 3993k \\
m32a &             &       &       &   2  & 4192k & 14  & 3939k & 10  & 4015k \\
    \hline
m32  &       8M    & 0xA4  & 19.2k &  -7  & 8425k &  6  & 7888k & 3  & 7983k \\
m32a &             &       &       &   2  & 8408k & 14  & 7921k & 11  & 8014k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega32}
  \label{tab:mega32freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
        AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -11  & 1047k &  1  & 982k  & -2  & 998k \\
    \hline
                2M & 0xA2  & 19.2k &  -12  & 2099k &  0  & 1971k & -3 & 1995k \\
    \hline
                4M & 0xA3  & 19.2k &  -9  & 4291k &  3  & 3932k & 0  & 4002k \\
    \hline
                8M & 0xA4  & 19.2k &  -11 & 8415k & 2  & 7857k & -2  & 8013k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega16A}
  \label{tab:mega16freq}
\end{table}

Immer wenn in der MinCorr Spalte positive Werte oder in der MaxCorr Spalte negative
Werte auftauchen, ist bei dieser Frequenz und diesem Prozessor-Exemplar der Betrieb
der seriellen Schnittstelle ohne Korrektur nicht möglich.
Wenn eine 0 in den Spalten auftaucht, ist der Betrieb der seriellen Schnittstelle
gerade eben noch möglich.

\subsection{Untersuchung des RC-Generators des ATmega163L}

Der ATmega163L besitzt nur einen \(1MHz\) RC-Generator, der mit dem OSCCAL Register
abgestimmt werden kann. Mein Exemplar hatte keine Voreinstellung des OSCCAL Wertes.
Daher sind hier außergewöhnlich hohe Korrekturwerte erforderlich, um die Frequenz
auf etwa \(1MHz\) einstellen zu können.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
        AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0x92  &  9.6k &  -88  & 1026k &  -62  & 964k  & -77  &  998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenz des ATmega163L}
  \label{tab:mega163freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren des ATmega64 / 128}

Der ATmega64 und der ATmega128 können 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, \(1MHz\), \(2MHz\), \(4MHz\) und \(8MHz\).
In den Tabellen \ref{tab:mega64freq} und \ref{tab:mega128freq} habe ich alle 
4 Frequenzeinstellungen untersucht.
An dieser Stelle sei auch ein Hinweis erlaubt, das das Laden der Programmdaten über die 
ISP-Schnittstelle nicht mit den Signalen MISO und MOSI, sondern über die Signale TXD (PE1) und RXD (PE0)
erfolgt. Dies muß natürlich beim Anschluß an den Programmer berücksichtigt werden.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
        AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -4  & 1024k &  6  & 975k  & 1  & 1000k \\
    \hline
                2M & 0xA2  & 19.2k &  -4  & 2047k &  6  & 1952k & 0  & 2015k \\
    \hline
                4M & 0xA3  & 19.2k &   4  & 4070k & 10  & 3939k & 8  & 3976k \\
    \hline
                8M & 0xA4  & 57.6k &   6  & 8028k & 10  & 7847k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega64}
  \label{tab:mega64freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
        AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -9  & 1051k &  3  & 985k  & 0  &  999k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2102k &  3  & 1971k & 0  & 2000k \\
    \hline
                4M & 0xA3  & 19.2k &  -3  & 4209k &  9  & 3960k & 6  & 4006k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8225k & 13  & 7723k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega128}
  \label{tab:mega128freq}
\end{table}

Die Tabellen zeigen, daß für den \(1Mhz\) und \(2MHz\) Betrieb eine Korrektur des
OSCCAL Registers nicht erforderlich ist. Bei \(4MHz\) und \(8MHz\) Betrieb kann die serielle Schnittstelle
aber beim untersuchten ATmega64 nicht ohne Korrektur betrieben werden.
Ohne Korrektur wäre die 4MHz Frequenz um etwa 4\% zu hoch und die \(8MHz\) Frequenz um etwa 4.3\% zu hoch.
In der Dokumentation von Atmel wird übrigens abgegeben, daß der
RC-Generator des ATmega64 und ATmega128 bei \(1MHz\) abgeglichen wird.
Es sei noch einmal darauf hingewiesen, daß es sich bei den Tabellendaten um die Untersuchung eines einzelnen 
Exemplars des ATmega handelt. Außerhalb der angegebenen Min- bzw. Max-Werte der OSCCAL Korrekturen war
ein Betrieb der seriellen Schnittstelle bei der angegebenen Baud-Rate nicht möglich.

\subsection{Untersuchung der RC-Generatoren der ATmega644 Familie}

Bei der ATmega644 Familie kann  eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Daneben kann
auch noch ein \(128kHz\) Gererator als Takt gewählt werden, der sonst den Watchdog-Timer versorgt.
Die gewählte Frequenz kann aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden,
so daß auch ein \(1MHz\) Betrieb eingestellt werden kann.
Die Tabelle~\ref{tab:mega644freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1284p &          8M & 0xC2  & 19.2k & -8  & 8416k & 7  & 7882k  & 4  & 7989k \\
    \hline
mega644p &          8M & 0xC2  & 19.2k &  -12 & 8416k & 3  & 7871k  & -1  & 8009k \\
    \hline
mega324p &          8M & 0xC2  & 19.2k &  -12 & 8398k & 3  & 7885k  & 0  & 7976k \\
    \hline
mega164p &          8M & 0xC2  & 19.2k &  -5  & 8401k & 4  & 7888k  & 2  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega644 Familie}
  \label{tab:mega644freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATmega645 Familie}

Bei der ATmega645 Familie kann nur eine RC-Oszillatorfrequenz von \(8MHz\) gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein \(1MHz\) Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega645freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &   AVR\_ & LFUSE & Baud- & \multicolumn{2}{c |}{Minimum} & \multicolumn{2}{c |}{Maximum} & \multicolumn{2}{c |}{Best} \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega165p &         8M & 0xE2  & 57.6k & -6  & 8235k &  7  & 7718k  & -1  & 8015k \\
    \hline
mega325  &         8M & 0xE2  & 38.4k & -10 & 8403k &  5  & 7868k  &  1  & 7992k \\
    \hline
mega645 &          8M & 0xE2  & 57.6k &  0  & 8253k & 12  & 7726k  & 5  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega645 Familie}
  \label{tab:mega645freq}
\end{table}

Beim ATmega645 ist der Betrieb der seriellen Schnittstelle ohne OSCCAL Korrektur gerade noch möglich.
Sicherer ist aber der Betrieb mit OSCCAL\_CORR=5, da dann die \(8MHz\) besser eingehalten werden. 

\subsection{Untersuchung der RC-Generatoren der ATmega649 Familie}

Bei der ATmega649 Familie kann nur eine RC-Oszillatorfrequenz von \(8MHz\) gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein \(1MHz\) Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega649freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega169 &          8M & 0xE2  & 57.6k &  -9  & 8250k & 2  & 7864k  & -2  & 8010k \\
    \hline
mega329 &          8M & 0xE2  & 38.4k &  -2  & 8330k & 7  & 7877k  &  4  & 8013k \\
    \hline
mega649 &          8M & 0xE2  & 38.4k &  -2  & 8370k & 8  & 7895k  &  6  & 7988k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega649 Familie}
  \label{tab:mega649freq}
\end{table}

\subsection{Untersuchung des RC-Generators der ATmega2560 Familie}

Bei der ATmega2560 Familie kann  eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Daneben kann
auch noch ein \(128kHz\) Gererator als Takt gewählt werden, der sonst den Watchdog-Timer versorgt.
Die gewählte Frequenz kann aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden,
so daß auch ein \(1MHz\) Betrieb eingestellt werden kann.
Die Tabelle~\ref{tab:mega2560freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1281 &          8M & 0xC2  & 38.4k &  -5 & 8405k & 5 & 7871k   & 2  &  8012k \\
    \hline
mega2561 &          8M & 0xC2  & 38.4k &  -8 & 8363k & 4  & 7870k  & 1  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega2560 Familie}
  \label{tab:mega2560freq}
\end{table}

Das Laden von mehr als 128KByte Daten wurde mit dem ATmega2561 erfolgreich getestet.
Normalerweise beginnen die Anwenderdaten für den Flash-Speicher bei der Addresse 0.
Das ist für den Daten-Download über die serielle Schnittstelle nicht unbedingt erforderlich.
Die Anfangs-Addresse muß aber auf jeden Fall unter 128K (0x20000) liegen, 
damit das Laden von Daten in die obere Speicherhälfte funktioniert.
Die Option VIRTUAL\_BOOT\_PARTITION kann bei Prozessoren mit mehr
als 128Kbyte Flash Speicher nicht benutzt werden.

\subsection{Untersuchung der RC-Generatoren der ATtiny4313 Familie}

Beim ATtiny4313 und ATtiny2313 kann der interne RC-Generator bei \(8MHz\) oder
bei \(4MHz\) betrieben werden. Außerdem ist auch noch ein interner \(128kHz\) Generator
wählbar, der aber nicht kalibriert werden kann.
Die Tabelle \ref{tab:tiny4313freq} zeigt die Ergebnisse der Frequenzmessung beim
\(8MHz\) und \(4MHz\) Betrieb

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
tiny4313 &         8M & 0xE4  & 38.4k &  -4  & 8342k & 0  & 7975k  & -1  & 7983k \\
         &            &       &       &  -2  & 8326k & 3  & 7905k  & 1  & 8010k \\
    \hline
tiny2313 &         8M & 0xE4  & 38.4k &  -4  & 8400k & 3  & 7909k  &  2  & 7980k \\
    \hline
tiny4313 &         4M & 0xE2  & 38.4k &  -6  & 4193k & -3  & 3976k  & -3  & 3976k \\
         &            &       &       &   1  & 4169k & 6  & 3961k  & 5  & 4017k \\
    \hline
tiny2313 &         4M & 0xE2  & 38.4k &   0  & 4160k & 6  & 3960k  &  5  & 3998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny4313 Familie}
  \label{tab:tiny4313freq}
\end{table}

Bei allen drei vorhandenen ATtinys dieser Serie hat sich das Einstellen der Frequenz
als schwierig erwiesen weil sich die Frequenz bei kleiner OSCCAL Korrektur schon
relativ stark ändert.



\subsection{Untersuchung der RC-Generatoren der ATtiny84 Familie}

Bei der ATtiny84 Familie kann außer dem \(8MHz\) RC-Oszillator auch noch der 
\(128kHz\) Takt der Watchdog-Schaltung benutzt werden.
Der \(128kHz\) Takt kann nicht kalibriert werden. Wenn man diesen Takt benutzen möchte,
kann man die erzeugte Baudrate nur über den vorgegebenen Wert korrigieren.
Bei einem ATtiny24a habe ich die erzeugte Baudrate kontrolliert. Statt der
eingestellten 2400 Baud habe ich nur 2170 Baud gemessen. Das ergibt einen Frequenzfehler
von etwa 9.6\% und damit deutlich zu viel, um ohne Korrektur benutzt werden zu können.
Bei eingestellten 2640 Baud funktionierte der Download mit 2400 Baud.
Die gemessene Taktrate betrug dann nur \(115.2kHz\) anstelle der \(128kHz\).
Die Tabelle~\ref{tab:tiny84freq} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den \(8MHz\) Betrieb dar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny84 &          8M & 0xE2  & 19.2k &  -6  & 8453k & 14  & 7673k  & 5  & 8019k \\
    \hline
attiny44a &         8M & 0xE2  & 19.2k &  -16  & 8367k & 3  & 7673k  & 7  & 7984k \\
    \hline
attiny24a &         8M & 0xE2  & 19.2k &  -4  & 8388k & 11  & 7685k  & 4  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny84 Familie}
  \label{tab:tiny84freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATtiny85 Familie}

Bei der ATtiny84 Familie kann außer dem \(8MHz\) RC-Oszillator auch noch der 
ein \(6.4MHz\) RC-Oszillator und der \(128kHz\) Takt der Watchdog-Schaltung benutzt werden.
Der \(6.4MHz\) RC-Oszillator wird aber immer mit einem Frequenzteiler auf \(1.6MHz\)
heruntergeteilt.
Der \(128kHz\) Takt kann nicht kalibriert werden. Wenn man diesen Takt benutzen möchte,
kann man die erzeugte Baudrate nur über den vorgegebenen Wert korrigieren.
Die erste Tabelle~\ref{tab:tiny85freq8} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den \(8MHz\) Betrieb dar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &          8M & 0xE2  & 38.4k &  -4  & 8370k &  9  & 7714k  & 3  & 8012k \\
    \hline
attiny45  &         8M & 0xE2  & 38.4k &  -4  & 8400k & 9  & 7706k  & 3  & 8030k \\
    \hline
attiny25  &         8M & 0xE2  & 38.4k &  -9  & 8424k & 46  & 7724k  & 40  & 8034k \\
attiny25  &         8M & 0xE2  & 38.4k &  -12  & 8399k & 7  & 7680k  & -2  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei 8MHz}
  \label{tab:tiny85freq8}
\end{table}

Die Einstellwerte bei einem ATtiny25 sehen merkwürdig aus, aber bei der Korrektur 3 hat
der OSCCAL Wert die Zahl 128 unterschritten und ist damit in einem anderen Stellbereich.
Erst bei einem Korrekturwert von etwa 34 wurde dann wieder eine Frequenz von \(8364kHz\)
erreicht, bei der die serielle Schnittstelle wieder betrieben werden kann. Eine ähnliche
Frequenz wurde im anderen Stellbereich beim Korrekturwert -6 erreicht.
Die nächste Tabelle~\ref{tab:tiny85freq1} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den \(1.6MHz\) Betrieb dar. Der RC-Generator läuft dabei bei \(6.4MHz\),
diese Frequenz wird aber immer durch Faktor 4 geteilt. 

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xD3  & 9.6k &  -7  & 1684k &  9  & 1547k  & 2  & 1603k \\
    \hline
attiny45  &        1.6M & 0xD3  & 9.6k &  -5  & 1684k & 11  & 1559k  & 4  & 1603k \\
    \hline
attiny25  &        1.6M & 0xD3  & 9.6k &  -7   & 1689k & 10 & 1543k  & 3  & 1602k \\
attiny25  &        1.6M & 0xD3  & 9.6k &  -10  & 1680k & 3  & 1550k  & -3  & 1609k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei \(1.6MHz\)}
  \label{tab:tiny85freq1}
\end{table}

Bei dem Betrieb mit \(1.6MHz\) hat sich die Besonderheit mit der OSCCAL Korrektur-Einstellung
nicht gezeigt. Alle untersuchten Exemplare würden auch ohne Korrektur der Frequenz
mit der seriellen Schnittstelle arbeiten können.
Die ATtiny84 Prozessor Familie kann den Prozessor auch mit einem PLL-Oszillator betreiben,
der vom \(8MHz\) RC-Oszillator kontrolliert wird. Der PLL-Oszillator kann entweder \(64MHz\) oder
\(32MHz\) erzeugen, die normalerweise für den T1 Zähler benutzt werden können.
Wenn der PLL-Takt als Prozessor-Takt verwendet werden soll, kann der PLL-Oszillator nur
bei \(64MHz\) arbeiten und wird immer durch Faktor 4 geteilt. Somit ergeben sich 16MHz 
für den Prozessortakt. Die Tabelle~\ref{tab:tiny85freq16} zeigt die gemessenen
Resultate. Erwartungsgemäß weichen diese Ergebnisse nicht wesentlich von den \(8MHz\) Ergebnissen
ab.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xF1  & 38.4k &  -4  & 16.87M &  10  & 15.41M  & 4  & 16.02M \\
    \hline
attiny45  &        1.6M & 0xF1  & 38.4k &  -4  & 16.87M & 10  & 15.41M  & 4  & 15.95M \\
    \hline
attiny25  &        1.6M & 0xF1  & 38.4k &  -9   & 16.91M & 47 & 15.38M  & 41  & 16.03M \\
attiny25  &        1.6M & 0xF1  & 38.4k &  -11  & 16.82M & 7  & 15.43M  & -2  & 16.07M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei 16MHz}
  \label{tab:tiny85freq16}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATtiny841 Familie}

Der ATtiny841 und der ATtiny441 haben ebenfalls einen \(8MHz\) RC-Generator,
der abgestimmt werden kann. Für die Unterstützung dieser Familie waren einige
Anpassungen beim Optiboot Bootloader erforderlich.
In der Tabelle~\ref{tab:tiny841freq8} sind die Ergebnisse der untersuchten Exemplare
dargestellt.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny841 &          8M & 0xE2  & 38.4k &  -4  & 8369k & 10  & 7861k  & 6  & 8003k \\
          &             &       &       &  -5  & 8389k &  9  & 7874k  & 6  & 7990k \\
    \hline
attiny441  &         8M & 0xE2  & 38.4k &  -4  & 8399k & 10 & 7870k  & 7  & 7985k \\
           &            &       &       &  -4  & 8380k &  9 & 7900k  & 7  & 7985k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny841 Familie bei 8MHz}
  \label{tab:tiny841freq8}
\end{table}

Bei allen untersuchten Exemplaren kann die serielle Schnittstelle auch ohne die
OSCCAL-Korrektur benutzt werden.


\subsection{Untersuchung der RC-Generatoren der ATtiny861 Familie}

Bei der ATtiny861 Familie kann außer dem \(8MHz\) RC-Oszillator noch ein PLL-Oszillator
und der \(128kHz\) Takt der Watchdog-Schaltungs als Prozessor-Takt benutzt werden.
Der \(128kHz\) Takt der Watchdog-Schaltung kann aber nicht kalibriert werden und
kommt daher für die Bootloader-Anwendung nicht in Frage.
Der PLL-Oszillator hat für den Prozessor eine Frequenz von \(16MHz\), kann aber leider
nur vom internen RC-Oszillator synchronisiert werden. Daher kann mit dem PLL-Oszillator
keine genaue Zeitmessung durchgeführt werden.
Die erste Tabelle~\ref{tab:tiny861freq8} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den \(8MHz\) Betrieb dar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny861 &          8M & 0xE2  & 38.4k &  -2  & 8415k & 18  & 7693k  & 9  & 8007k \\
          &             &       &       &  -1  & 8436k & 19  & 7678k  & 10 & 8011k \\
    \hline
attiny461  &         8M & 0xE2  & 38.4k &  -2  & 8418k & 17 & 7690k  & 9  & 7995k \\
           &            &       &       &  -4  & 8380k & 14 & 7695k  & 3  & 8030k \\
    \hline
attiny261  &         8M & 0xE2  & 38.4k &  -4  & 8403k & 17 & 7710k  & 9  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny861 Familie bei \(8MHz\)}
  \label{tab:tiny861freq8}
\end{table}

Beim ATtiny261 habe ich auf das optionale LED-Blinken beim Start von Optiboot verzichtet,
damit genug Platz für das Testprogramm zur Verfügung steht (Option LED\_START\_FLASHES=0).


\subsection{Untersuchung des RC-Generators der ATtiny88 Familie}

Die ATtiny88 Familie kann außer einem \(8MHz\) internem RC-Generator nur noch einen
nicht kalibrierbaren \(128kHz\) Generator oder einen externen Takt als Taktgeber für
den Prozessor wählen. Ein Frequenzteiler mit Faktor 8 ist für den Prozessortakt
bei der LFUSE auch einstellbar. In der Tabelle~\ref{tab:tiny88freq} sind die Ergebnisse
für die Kalibration des internen \(8MHz\) Generators bei zwei Exemplaren der Familie dargestellt. 

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny88 &          8M & 0xE2  & 38.4k &  -4  & 8397k & 15  & 7682k  & 6  & 8013k \\
    \hline
attiny48 &         8M & 0xE2  & 38.4k &  -5  & 8385k & 12  & 7739k  & 5  & 7995k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny88 Familie}
  \label{tab:tiny88freq}
\end{table}

Bei beiden Exemplaren läuft die serielle Schnittstelle ohne Frequenz-Korrektur. 
Die Takt-Frequenz wird aber bei einer Korrektur von 5 (6) besser eingehalten.

\subsection{Untersuchung der RC-Generatoren des ATtiny1634}

Für den ATtiny1634 habe ich zwei Exemplare mit dem \(8MHz\) internem RC-Generator
untersucht. Neben der Frequenz kann auch noch der Frequenz-Temperaturgang des
RC-Generators mit zwei zusätzlichen Kalibrations-Registern eingestellt werden.
Den Abgleich des Temperaturgangs habe ich in der Tabelle~\ref{tab:tiny1634freq}
nicht untersucht. Neben dem \(8MHz\) RC-Generator kann bei diesem Prozessor
auch die Frequenz des internen \(32kHz\) Generators mit einem zusätzlichen
Kalibrations-Register (OSCCAL1) abgeglichen werden. Das wird derzeit aber noch
nicht vom Optiboot Bootloader unterstützt.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
   AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
         8M & 0xE2  & 19.2k &  -5  & 8404k &  9  & 7867k  & 6  & 7983k \\
         8M & 0xE2  & 19.2k &  -7  & 8410k &  7  & 7867k  & 4  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für den ATtinye1634}
  \label{tab:tiny1634freq}
\end{table}

\subsection{Untersuchung des RC-Generators der AT90PWM Familie}

Neben dem üblichen \(8MHz\) RC-Generator hat die AT90PWM Familie noch einen
PLL-Oszillator, der vom \(8MHz\) Generator synchronisiert wird.
Mit dem PLL-Oszillator kann der Prozessor mit \(16MHz\) betrieben werden.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90pwm2b &         8M & 0xE2  & 38.4k &  -13  & 8350k & -1  & 7862k  & -5  & 8020k \\
    \hline
at90pwm3  &         8M & 0xE2  & 38.4k &  -10  & 8359k &  4  & 7885k  & 1  & 7991k \\
    \hline
at90pwm2b &        16M & 0xE3  & 38.4k &  -14  & 16.74M & -1  & 15.74M  & -4  & 15.97M \\
    \hline
at90pwm3  &        16M & 0xE3  & 38.4k &  -10  & 16.79M &  5  & 15.79M  & 2  & 15.98M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die AT90PWM Familie}
  \label{tab:t90pwmfreq}
\end{table}

Beim untersuchten AT90PWM2B wäre der Betrieb der seriellen Schnittstelle ohne
die OSCCAL-Korrektur nicht möglich gewesen.

\subsection{Untersuchung des RC-Generators der AT90CAN Familie}

Untersucht habe ich nur jeweils ein Exemplar AT90CAN32 und AT90CAN128.
Beide Exemplare können nur einen internen \(8~MHz\) RC-Oszillator wählen.
Alle anderen Wahlmöglichkeiten erfordern einen externen Quarz oder einen externen Taktgenerator.
Die Taktfrequenz kann optional auch mit dem Faktor 8 geteilt werden,
so daß auch \(1~MHz\) Betrieb mit dem internen Takt möglich ist.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90can32 &         8M & 0xE2  & 38.4k &  0  & 8379k & 6  & 7920k  & 5  & 8019k \\
    \hline
at90can128 &         8M & 0xE2  & 38.4k &  0  & 8303k &  3  & 7922k  & 2  & 8057k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die AT90CAN Familie}
  \label{tab:t90canfreq}
\end{table}

