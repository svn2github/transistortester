\chapter{Der optiboot Bootloader für AVR Mikrocontroller}

\section*{}
Der optiboot Bootloader wurde in der Sprache C von Peter Knight und
Bill Westfield entwickelt. Die Version 6.2 habe ich als Basis
für die hier beschriebene überarbeitete Assembler Version benutzt.
Dabei möchte ich betonen, daß ich den optiboot Bootloader nicht
neu erfunden habe, sondern lediglich weiter optimiert. 
Viele Anpassungen an verschiedene Zielprozessoren und spezielle
Platinenentwürfe waren bereits in der Version 6.2 vorhanden.
Es werden Teile des STK500 Kommunikations-Protokols benutzt,
die in der AVR061~\cite{stk500} von Atmel veröffentlicht wurde.


\section{Änderungen und Weiterentwicklung von Version 6.2}
Im wesentlichen habe ich das komplette Programm in die Assembler-
Sprache umgeschrieben und die Makefile so angepasst, daß die Programmlänge
automatisch weiterverarbeitet wird und damit die Startadresse
des Bootloaders sowie die Fuses des ATmega richtig eingestellt werden.
Die eingeschlagene Lösung erzeugt während der Abarbeitung der Einzelschritte
für die Erzeugung des Programmcodes für den Bootloader noch weitere
kleine Dateien, welche in den nachfolgenden Schritten für die Anpassung
der Start-Adresse und der Fuses erforderlich sind.
Die Startadresse für den jeweiligen Zielprozessor ist abhängig von
der vorhandenen Flash-Speichergröße,
dem Speicherbedarf für den aktuellen Bootloader-Code und
der Kachelgröße, die für Bootloader beim Zielprozessor zur Verfügung steht.
Als Kachelgröße bezeichne ich die kleinste Speichergröße für Bootloader,
die der jeweilige Prozessor zur Verfügung stellen kann.


Bei Prozessoren wie der ATtiny84, die keine Bootloader Startadresse einstellen können,
wird die Seitengröße des Flash-Speichers für die Berechnung benutzt.
Beim ATtiny84 sind das 64 Bytes. Damit liegt die Startadresse des Bootloaders immer
am Anfang einer Flash Speicherseite. 

Bei allen anderen Zielprozessoren kann der Bootloader-Bereich mit den
Fuse-Bits BOOTSZ1 und BOOTSZ0 eingestellt werden (jeweils mit den Werten 0 und 1).
Wenn man die beiden Bits zusammensetzt, ergibt sich daraus die
Bootloader-Größe BOOTSZ mit Werten zwischen 0 und 3.
Dabei bedeutet 3 immer den kleinsten mögliche Bootloader Speicherbereich.
Der Wert 2 gibt den doppelten, der Wert 1 den vierfachen und
der Wert 0 den acht-fachen Speicherbereich vor.
Die Tabelle~\ref{tab:bootsz} auf Seite~\pageref{tab:bootsz} gibt einen
Überblick für verschiedene Zielprozessoren.

\section{Automatische Größenanpassung in der optiboot Makefile}

Die Bootloader Startadresse und die benötigte Bootloadergröße wird
automatisch in der Makefile angepasst. Für die Berechnungen werden
einige Zwischendateien erzeugt, was nur zusammen
mit den folgenden Linux Werkzeugen funktioniert:
\begin{description}
\item [bc] ein einfacher Rechner, der die Eingabe- und Ausgabe-Werte
sowohl dezimal als auch sedezimal (hex) verarbeiten kann.
\item [cat] gibt den Inhalt von Dateien auf der Standard-Ausgabe aus.
\item [cut] kann Teile von Zeilen einer Textdatei ausschneiden.
\item [echo] gibt den angegebenen Text auf der Standard-Ausgabe aus.
\item [grep] gibt nur Zeilen einer Textdatei mit dem angegebenen Suchtext aus.
\item [tr] kann Text-Zeichen ersetzen oder löschen.
\end{description}

Bisher ist die Funktion der Makefile nur mit einem Linux-System getestet.
Wahrscheinlich ist die Benutzung unter Windows nur möglich,
wenn das Cygwin Paket installiert wird.

Um die erzeugten Zwischendateien braucht man sich im Regelfall nicht zu kümmern. Hier
möchte ich aber wenigstens die Namen und die Bedeutung erwähnen:
\begin{description}
\item [BootPages.dat] enthält die Zahl der vom Bootloader benötigten Seiten.
Bei Prozessoren mit Bootloader Unterstützung kann die Zahl nur 1, 2, 4 oder 8 sein und
gibt an, das wie-vielfache der Mindest-Bootloadergröße verwendet wird.
Bei der virtuellen Bootloader Seite kann die Zahl beliebig sein und gibt die Zahl der
benötigten Flash-Speicherseiten an.
\item [BOOTSZ.dat] enthält eine Zahl zwischen 0 und 3 für die Einstellung der BOOTSZ0 und BOOTSZ1 Bits.
\item [BL\_StartAdr.dat] enthält die Startadresse des Bootloaders im sedezimal (hex) Format.
Die Startadresse wird berechnet aus der Flash-Speichergröße des jeweiligen Zielprozessors und
aus der Zahl der benötigten Speicherseiten.
\item [EFUSE.dat] enthält im sedezimal Format der Wert für die efuse. Die Makefile entscheidet
 abhängig vom Zielprozessor, ob diese Datei verwendet wird.
\item [HFUSE.dat] enthält im sedezimal Format der Wert für die hfuse. Die Makefile entscheidet
 abhängig vom Zielprozessor, ob diese Datei verwendet wird.
\end{description}

\section{Zielvorgaben für optiboot Makefile}

Die Steuerung des Ablaufs für die Generierung der Programmdaten aus
dem Quellcode ist in der Makefile festgelegt.
Außer der  Haupt Makefile gibt es noch weitere drei Erweiterungen
der Makefile, die automatisch von der Haupt Makefile integriert werden:
Makefile.1284, Makefile.atmel, und Makefile.extras .
Dabei können verschiedene Konfigurationen auch für einen Prozessortyp
festgelegt worden sein. In der Tabelle~\ref{tab:processors} sind die derzeit vordefinierten
Konfigurationen für AVR Prozessoren angegeben. Im Prinzip ist diese Liste natürlich erweiterbar.
Die einstellbaren Parameter sind aber auch in der Aufrufzeile des
make Programms als Parameter oder auch als Umgebungsvariable der Shell
einstellbar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
             Name  & MCU & AVR\_ & total & Flash & BP\_ & LFUSE & HFUSE & EFUSE  \\
                   &     & FREQ  & Flash & page  & LEN  &       &       &        \\
                   &     &       &  size & size  &      &       &       &        \\
    \hline
    \hline
         attiny84 & t84   & 16M? &  8K   &  64   & (64) &  62   &  DF   & FE \\
    \hline
         atmega8  & m8    & 16M  &  8K   &  64   & 256  &  BF   &  CC   &  - \\
    \hline
         atmega88 & m88   & 16M  &  8K   &  64   & 256  &  FF   &  DD   &  04 \\
    \hline
       atmega16   & m16   & 16M  &  16K  & 128   & 256  &  FF   &  9C   &  - \\
    \hline
       atmega168  &  m168  & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
       atmega168p &  m168p & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
    \hline
       atmega32   &  m32   & 16M  &  16K & 128   & 256  &  BF   &  CE   &  - \\
    \hline
       atmega328  &  m328  & 16M  &  32K & 128   & 512  &  FF   &  DE   &  05 \\
       atmega328p & m328p & 16M  &  32K  & 128   & 512  &  FF   &  DE   &  05 \\
    \hline
       atmega644p & m644p & 16M  &  64K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1284  & m1284  & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
     atmega1284p & m1284p & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1280  & m1280  & 16M  &  128K & 256   & 1K   &  FF   &  DE   &  05 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Prozessor targets für optiboot Makefile}
  \label{tab:processors}
\end{table}

Alle Angaben für Größen sind in Bytes angegeben, die Werte für die Fuses sind die sedezimalen
Werte (hex). Die Frequenz-werte werden in Hz angegeben, 16M entspricht also 16000000 Hz.
Die Standard Baud-Rate für die serielle Schnittstelle beträgt immer 115200.

Neben den universellen Konfigurationen gibt es auch Konfigurationen für bestimmte
Platinen oder Arbeitsumgebungen.
Die Tabelle~\ref{tab:boards} zeigt die unterschiedlichen Einstellungen.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
    \hline
             Name  & MCU & AVR\_ & BP\_ & L     & H     & E     & BAUD\_ & LED & SOFT\_ \\
                   &     & FREQ  & LEN  &  FUSE & FUSE  &  FUSE & RATE &     & UART \\
    \hline
    \hline
       luminet     & t84 &  1M   & 64v &  F7   &  DD   &  04   & 9600 & 0x  &  -   \\

    \hline
         virboot8  & m8    & 16M & 64v &       &       &       &      &     &      \\
    \hline
       diecimila  &  m168 & (16M) &     &  F7   &  DD   &  04   &      & 3x  &  -   \\
       lilypad    &  m168  & 8M  &      &  E2   &  DD   &  04   &  -   & 3x  &  -   \\
       pro8       &  m168  & 16M &      &  F7   &  C6   &  04   &  -   & 3x  &  -   \\
       pro16      &  m168  & 16M &      &  F7   &  DD   &  04   &  -   & 3x  &  -   \\
       pro20      &  m168  & 16M &      &  F7   &  DC   &  04   &  -   & 3x  &  -   \\
    atmega168p\_lp&  m168  & 16M &      &  FF   &  DD   &  04   &  -   &     &  -   \\
   xplained168pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
       virboot328  & m328p & 16M & 128v &       &       &       &      &     &  -   \\
    atmega328\_pro8& m328p & 8M  &      &  FF   &  DE   &  05   &  -   & 3x  &  -   \\
   xplained328pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
   xplained328p   &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
        wildfire  & m1284p & 16M &      &       &       &      &   -   & 3xB5 &      \\
    \hline
       mega1280    & m1280 & 16M &      &  FF   &  DE   &  05   &  -   &     &  -   \\
    \hline
    \end{tabular}
  \end{center}
  \caption{vorkonfigurierte targets für optiboot Makefile}
  \label{tab:boards}
\end{table}

\section{Die Optionen für die optiboot Makefile}

Mit den Optionen wird die Eigenschaft des optiboot Bootloaders eingestellt.
Beispielsweise kann mit der Option SOFT\_UART veranlasst werden, daß ein
Softwareprogramm für die serielle Kommunikation verwendet werden soll.
Sonst wird, wenn vorhanden, die auf dem Chip integrierte  serielle Schnittstelle
mit den Pins TX (Transmit = senden) und RX (Receive = empfangen) benutzt.
Bei mehreren integrierten seriellen Schnittstellen wird normalerweise die erste
Schnittstelle mit den Nummer 0 verwendet. Es kann aber auch jede andere vorhandene
Schnittstelle mit der Option UART vorgegeben werden (UART=1 für die zweite Schnittstelle).
Bei der Hardware UART Schnittstelle sind die Pins für Empfangen (RX) und Senden (TX)
fest verknüpft. Bei der Software-Lösung für die serielle Schnittstelle sind alle Pins
des AVR Prozessors frei für die serielle Kommunikation wählbar. Die einzige Bedingung
ist, daß die Pins für digitale Eingabe (RX) beziehungsweise Ausgabe (TX) geeignet sind.
Näheres zu den möglichen Optionen findet man in der Übersicht~\ref{tab:options1}
und \ref{tab:options2}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name der        & Beispiel       & Funktion                                            \\
    Option         &                &                                                     \\
    \hline
    \hline
    F\_CPU         & F\_CPU=8000000 & Teilt dem Programm die Taktrate des Prozessors mit. \\
                   &                & Die Angabe erfolgt in Hz (Schwingungen pro Sekunde. \\
                   &                & Das Beispiel gibt eine Frequenz von 8 MHz an. \\
    \hline
    BAUD\_RATE     & BAUD\_         & Gibt die Baud-Rate für die serielle Kommunikation an. \\
                   &  RATE=9600      & Es werden immer 8 Datenbits ohne Parity verwendet. \\
    \hline
    SOFT\_UART     & SOFT\_UART=1   & Wählt Software-Lösung für die serielle Kommunikation. \\
    \hline
    UART\_RX        & UART\_RX=D0   & Gibt den Port und die Bitnummer für die seriellen  \\
                   &                & Empfangsdaten an. Das Beispiel nimmt               \\
                   &                & Bit 0 des D Ports für den seriellen Eingang.\\
    \hline
    UART\_TX        & UART\_TX=D1   & Gibt den Port und die Bitnummer für die seriellen  \\
                   &                & Sendedaten an.  Das Beispiel nimmt                 \\
                   &                & Bit 1 des D Ports für den seriellen Ausgang.\\
    \hline
    UART           & UART=1         & Wählt für die  serielle Schnittstelle des Chips. \\
                   &                & Eine Auswahl setzt das Vorhandensein mehrerer \\
                   &                & Schnittstellen voraus. \\
    \hline
 LED\_START\_      & LED\_START\_   & Wählt für die Anzahl der Blink-Zyklen \\
   FLASHES         &   FLASHES=3    & für die Kontroll-LED.                            \\
                   &                & Bei 1 oder -1 wird nur einmal geblinkt ohne Wiederholung. \\
                   &                & Negative Vorgaben bewirken, daß in der Programmschleife \\
                   &                & das RX Bit der seriellen Schnittstelle überwacht wird. \\
                   &                & Sobald eingehende RX-Daten festgestellt werden, \\
                   &                & wird die Schleife abgebrochen. Bitte beachten Sie, \\
                   &                & daß das Blinken den Start des Anwenderprogramms \\
                   &                & verzögert. \\
    \hline
 LED               & LED=B3         & Wählt das Port-Bit für die  Kontroll-LED. \\
                   &                & Beim Beispiel würde eine an das Bit 3 des Port B \\ 
                   &                & angeschlossene LED blinken. Bei der \\
                   &                & LED\_START\_FLASHES  Option  blinkt die LED die\\
                   &                & angegebene Anzahl vor dem Kommunikations-Start. \\
                   &                & Mit der LED\_DATA\_FLASH Option leuchtet die \\
                   &                & LED auch während des Wartens auf Daten. \\
    \hline
 LED\_DATA\_       & LED\_DATA\_    & Die Kontroll-LED leuchtet während des Wartens auf \\
      FLASH        &    FLASH=1     & Empfangsdaten der seriellen Kommunikation.\\
    \hline
 TIMEOUT\_MS       & TIMEOUT\_      & Diese Option gibt eine Zeitschranke in Millisekunden \\
                   &  MS=2000       & vor für den Empfang von Boot-Daten. Nach dieser Zeit\\
                   &                & wird der Bootvorgang abgebrochen und versucht, das \\
                   &                & Anwenderprogramm zu starten. Mögliche Werte für \\
                   &                & TIMEOUT\_MS sind 500, 1000, 2000, 4000 und 8000. \\
                   &                & Der tatsächlich mögliche Wert kann abhängig vom \\
                   &                & Prozessor aus 2 Sekunden begrenzt sein. \\
                   &                & Wenn kein TIMEOUT\_MS angegeben wird, wird die \\
                   &                & Zeitschranke auf 1 Sekunde gesetzt. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Wichtige Optionen für die optiboot Makefile}
  \label{tab:options1}
\end{table}

Bei Betrieb mit internem RC-Generator ist es durchaus möglich, daß ein serieller Datentransfer
nicht auf Anhieb gelingt. Das ist prinzipiell auch unabhängig davon, ob die Hardware UART
Schnittstelle oder eine Softwarelösung (SOFT\_UART) benutzt wird. Ohne zusätzliche Messungen
ist man dann auf Probieren mit der OSCCAL\_CORR angewiesen. Einen Hinweis kann
das Datenblatt des Prozessors liefern. Hier ist beschrieben, bei welcher Betriebsspannung
und bei welcher Temperatur der RC-Oszillator kalibriert wurde. Außerdem ist der
prinzipielle Verlauf der Frequenzänderung mit der Betriebsspannung, mit der Temperatur und
mit OSCCAL-Änderung beschrieben. 


Weitere Optionen sind in der Tabelle~\ref{tab:options2} aufgezählt. 
Diese Optionen sind nur für Software-Untersuchungen, die Frequenzkalibration des RC-Generators
 und für Prozessoren ohne Bootloader-Bereich interessant.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name der        & Beispiel       & Funktion                                            \\
    Option         &                &                                                     \\
    \hline
    \hline
    SUPPORT\_      & SUPPORT\_      & Wählt für das Bootloader-Programm die Lese- und Schreib- \\
    EEPROM         &  EEPROM=1      & Funktion für EEproms. Wenn als Quelle das Assembler- \\
                   &                & Programm gewählt wurde, ist die EEprom Unterstützung \\
                   &                & ohne gesetzte Option eingeschaltet, kann aber abgeschaltet\\
                   &                & werden, wenn die SUPPORT\_EEPROM Option auf 0 \\
                   &                & gesetzt wird. \\
                   &                & Bei der C-Quelle muß die Funktion mit der Option \\
                   &                & eingeschaltet werden (Standard = aus). \\
    \hline
 C\_SOURCE         & C\_SOURCE=1    & Wählt als Programmquelle das C-Programm anstelle des  \\
                   &                & Assembler-Programms (0 = Assembler).\\
                   &                & Die Assembler Version benötigt weniger Speicherplatz. \\
    \hline
 BIGBOOT           & BIGBOOT=512    & Wählt zusätzlichen Speicherverbrauch für das Bootloader- \\
                   &                & Programm. Das dient nur zum Test der automatischen \\
                   &                & Anpassung an die Programmgröße in der Makefile. \\
    \hline
VIRTUAL\_          & VIRTUAL\_       &  Ändert die Programmdaten eines Anwenderprogramms \\
 BOOT\_            & BOOT\_          & so ab, daß der Bootloader beim Reset angesprochen \\
 PARTITION         & PARTITION       & wird. Für den Start des Anwenderprogramms wird \\
		   &                 & ein anderer Interrupt-Vektor benutzt.          \\
    \hline
 save\_vect\_      & save\_vect\_    & Wählt eine Interrupt-Vektornummer für die  \\
      num          &    num=4        & VIRTUAL\_BOOT\_PARTITION Methode aus.        \\
    \hline
 OSCCAL\_          & OSCCAL\_       & Mit der Option OSCCAL\_CORR kann der interne \\
 CORR              & CORR=5         & 8~MHz RC-Generator des AVR abgeglichen werden. \\
                   &                & Ist bei Quarz-Betrieb oder externem Takt unwirksam! \\
                   &                & Der Korrekturwert wird vom voreingestellten OSCCAL Byte \\
                   &                & abgezogen. Bei positivem Korrekturwert wird die Frequenz \\
                   &                & normalerweise niedriger. Da die erzeugte Baud-Rate direkt \\
                   &                & vom Prozessortakt abhängt, ist ein richtig eingestellter \\
                   &                & Prozessortakt für eine erfolgreiche serielle Kommunikation \\
                   &                & wichtig. Der Wert sollte zwischen -20 und +20 liegen. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Weitere Optionen für die optiboot Makefile}
  \label{tab:options2}
\end{table}

\section{Benutzung von optiboot ohne Bootloader-Bereich}

Für Prozessoren ohne speziellen Bootloader-Bereich im Flash-Speicher wie dem ATtiny84 ist
eine Möglichkeit vorgesehen, trotzdem optiboot zu benutzen. 
Diese Funktion wird mit der Option VIRTUAL\_BOOT\_PARTITION gewählt.
Dabei wird im Anwenderprogramm auf der Reset-Vektoradresse die Start-Adresse des Bootloaders
eingetragen damit bei einem Reset immer der Bootloader zuerst angesprochen wird.
Die Start-Adresse des Anwender-Programms wird dabei auf die Adresse eines anderen
Interrupt-Vektors verlegt. Dieser Interrupt-Vektor sollte vom Anwenderprogramm nicht benutzt werden.
Wenn der Bootloader in angemessener Zeit keine Daten von der seriellen Schnittstelle
empfängt, springt er zu dem Sprungbefehl, der auf der ,,Ersatz''-Vektoradresse steht und
startet damit das Anwenderprogramm.
Die Abbildung~\ref{fig:VectorMove} soll die Veränderung verdeutlichen.

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/VectorMove.eps}
\caption{Veränderung der Programmdaten durch optiboot}
\label{fig:VectorMove}
\end{figure}

Auf der linken Seite ist der Inhalt der Datei dargestellt, welche die Programmdaten (.hex) enthält.
Rechts daneben ist der Inhalt des Flash-Speichers dargestellt, wie er vom Optiboot Bootloader
geschrieben wird. An zwei Interruptvektor-Adressen wurde der Inhalt verändert.
Einmal wurde auf dem Reset-Vektor 0 der Optiboot Bootloader eingetragen und zum anderen
auf der ,,Ersatz''-Vektor Adresse 4 ein Sprung zum Start des Applikations-Programms eingetragen. 
Eine Schwierigkeit bei der Methode entsteht aber dadurch, daß die Programmdaten nach
der Programmierung meistens zur Kontrolle zurückgelesen werden.
Damit bei der Kontrolle keine Fehler gemeldet werden, gibt Optiboot nicht den wirklichen Inhalt
der Interrupt-Vektortabelle zurück, sondern den Zustand vor seiner Manipulation.
Die Sprung-Adresse im Reset-Vektor kann dafür aus den Daten des ,,Ersatz''-Interruptvektors rekonstruiert werden.
Aber die ursprünglichen Daten des ,,Ersatz''-Interruptvektors wären verloren, da sie an keiner
Stelle der Vektortabelle wiederzufinden sind.
Optiboot benutzt zum Sichern des Original-Inhaltes des ,,Ersatz''-Vektors deshalb die beiden letzten
Bytes des EEprom-Speichers.
Damit ist eine Kontrolle der Programmdaten solange möglich, wie die beiden letzten Bytes
des EEproms nicht überschrieben werden.
Selbst wenn die EEprom Daten überschrieben werden, bleibt der Bootloader funktionsfähig.
Nur die Kontrolle (verify) der Programmdaten ist dann nicht mehr möglich. Bei der Adresse
des ,,Ersatz''-Interruptvektors wird dann ein Fehler gemeldet.

Bei Prozessoren mit mehr als 8 kByte Flash Speicher werden zwei Befehlsworte für jeden Interrupt-Vektor
vorgesehen. Normalerweise stehen auf diesen Doppelworten jmp Befehle mit den jeweiligen Sprungzielen.
Auch diese Art der Vektortabelle wird von Optiboot berücksichtigt. Wenn aber für das Bindeprogramm
(Linker avr-ld) die Option --relax verwendet wird,
werden alle jmp Befehle durch die kürzeren rjmp Befehle ersetzt,
wenn dies bei der jeweiligen Sprungadresse möglich ist.
Dies wird derzeit nicht von optiboot berücksichtigt.
Das Optiboot Programm geht fest davon aus, daß in der Vektortabelle jmp Befehle stehen,
wenn mehr als 8 kByte Flash-Speicher vorhanden sind.
Deshalb wird die VIRTUAL\_BOOT\_PARTITION Methode meistens nicht funktionieren, wenn die --relax Option
beim Programmbinden benutzt wurde!


Weiter ist zu beachten, daß bei Benutzung der VIRTUAL\_BOOT\_PARTITION Option für Prozessoren, die auch
die normale Bootloader Unterstützung bieten, das BOOTRST Fuse Bit nicht aktiviert wird.
Der Grund hierfür ist, daß bei Benutzung der VIRTUAL\_BOOT\_PARTITION die Start-Adresse des Bootloaders
auf einer anderen Adresse liegen kann wie bei der normalen Bootloader Unterstützung.
Bei Benutzung der Option VIRTUAL\_BOOT\_PARTITION kann die Startadresse auf jedem Anfang einer
Seite des Flash-Speichers liegen. Bei der normalen Bootloader Unterstützung kann immer nur das
einfache, doppelte, vierfache oder achtfache einer Mindest-Bootloadergröße berücksichtigt
werden (BOOT\_SZ Fuse-Bits), wie es in Abbildung~\ref{fig:pages} auf Seite~\pageref{fig:pages}
dargestellt wird.

\section{Die Möglichkeiten der seriellen Schnittstelle mit der verwendeten Software}

Das Programm für die Erzeugung und Verarbeitung der elektrischen Signale ist in AVR-Assembler geschrieben.
Die Arbeitsweise ist von der Veröffentlichung von Atmel übernommen.
Allerdings sind einige Besonderheiten eingebaut. 
So wird beispielsweise berücksichtigt, daß nicht für alle Port Adressen die speziellen Bitbefehle SBI, CBI
bzw SBIC benutzt werden können. Das ist nur bis zur Adresse 31 (0x1f) möglich. Für etwas größere
Port Adressen von 63 (0x3f) ist noch die Verwendung spezieller Einlese (IN) und Ausgabe (OUT) Befehle
möglich. Darüber liegende Adressen können nur mit den LDS und STS Befehlen erreicht werden.
Diese Befehle benötigen sowohl zwei Takte für die Ausführung und belegen auch den doppelten
Speicherplatz im Flash (2 Worte oder 4 Byte).
Die veränderte Taktzahl für einen Schleifendurchlauf ohne eine zusätzliche Verzögerung wird 
vom Programm automatisch ermittelt.
Diese Taktzahl wird dann für die Berechnung der Verzögerungsschleife berücksichtigt,
um eine korrekte Zeit für die Übertragung eines Bits zu erreichen. 
Die Diagramme~\ref{fig:getch_timing} und~\ref{fig:putch_timing} sollen  die Erzeugung der Schleife mit
dem C-Preprozessor verdeutlichen.

\begin{figure}[H]
\centering
\scalebox{0.9}{\includegraphics[]{../FIG/uart_getch_timing.eps}}
\caption{Mögliche Varianten der getch Funktion}
\label{fig:getch_timing}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/uart_putch_timing.eps}
\caption{Mögliche Varianten der putch Funktion}
\label{fig:putch_timing}
\end{figure}

Beide Schleifen werden so erzeugt, daß für die gleichen Bedingungen von INVERS\_UART und Adresse des verwendeten
Ports die gleiche Taktzahl gebraucht wird. Damit können dann beide Funktionen die gleiche
Funktion für die notwendige Verzögerung benutzen.

\subsection{Berechnung der Verzögerungszeit}
Für die Einlesefunktion getch() wird auch die halbe Baudzeit  gebraucht.
Von der Erkennung des Startbits wird 1.5 Mal die Baud-Zeit gewartet, um das erste Datenbit
einzulesen.
Deshalb ist die Basisschleife auf die halbe Zeitdauer einer Bitübertragung ausgelegt.
Für die ganze Baudzeit wird diese Basisschleife in einer speziellen Weise zwei mal aufgerufen,
damit exakt die doppelte Zeit eingehalten wird. Sollte durch die Bildung der Hälfte der Zeit und der
nachfolgenden Verdopplung ein Takt verloren gegangen sein, wird dieser Takt durch einen zusätzlichen
NOP Befehl ausgeglichen damit die Gesamtzeit für die Übertragung eines Bits auf einen Takt genau stimmt.
Wenn bei der Schleifenzeit ein oder zwei Takte wegen der Zeitauflösung (3 Takte) fehlen,
wird das automatisch durch einen zusätzlichen Befehl ausgeglichen.
Natürlich geschieht das alles automatisch, da für die Berechnung nur die Schleifenzeit der Einlesefunktion
(getch) bzw. Ausgabefunktion (putch), die Taktfrequenz des Prozessors und die gewünschte Baudrate
bekannt sein muß. Auch die übrigen Parameter wie die Anzahl der Takte für einen Unterprogramm-Aufruf
(RCALL, RET) sind für den Zielprozessor bekannt.
Ein Nachteil der Basis-Verzögerungsschleife ist die begrenzte Anzahl Takte für die Verzögerung.
Es sind wegen des verwendeten 8-Bit Zählers maximal 256*3 Takte für die Scheifenverzögerung möglich.
Dazu kommt noch der Unterprogrammaufruf von 7 Takten, wodurch sich für die halbe Verzögrungszeit dann 775 Takte ergeben.
Dieser Wert muß verdoppelt werden (Verzögerung für eine ganze Bitzeit) und dazu noch die Schleifenzeit der
Ausgabe- bzw. Eingabe dazugezählt werden. Somit ist die höchste erzielbare Verzögerungszeit 1559 Takte.
Bei 16 MHz Taktfrequenz sind so mit maximal \(97.4\mu s\) noch nicht einmal 9600 Baud (\(104.17 \mu s\)) einstellbar.
Würde man den Zähler der Zählschleife für die Verzögerungszeit von 8 Bit auf 16 Bit erweitern,
hätte man eine noch schlechtere Auflösung als die 3 Takte der 8-Bit Variante.
Außerdem käme die Schleife wahrscheinlich nicht wie die 8-Bit Variante ohne Veränderung des Übertragssignals (carry) aus.
Dieses Problem habe ich durch die schrittweise Verdopplung der Verzögerungszeiten durch Verdopplung der
Schleifenfunktion gelöst. Mit dem C-Preprozessor wird geprüft, ob der Anfangswert für die 8-Bit Zählschleife
bei der gewählten Taktfrequenz des Prozessors und der Baudrate größer als 255 sein würde.
Für diesen Fall wird die Berechnung für einen Doppelaufruf der Schleifenfunktion wiederholt. 
Wenn dann der Anfangswert für die Zählschleife immer noch zu hoch wäre, wird der Doppelaufruf noch einmal
verdoppelt. Diese Prüfung wird derzeit bis zum Faktor 64 des Basiszeit fortgesetzt.
Bei einer Taktfrequenz von 16 MHz oder 20 MHz sind so auf jeden Fall noch 300 Baud einstellbar.
Für jede Verdopplung der Verzögerungszeit wird ein zusätzlicher Befehl (2 Byte) benötigt. 
Bei der maximal möglichen Zahl der Verdopplung werden dann 6 zusätzliche Befehle (12 Byte) im Flash belegt.
Ein Ausgleich der durch die Vorteilung möglicherweise fehlenden Takte wird hier nicht durchgeführt,
um nicht unnötig Platz im Flash zu belegen.
Da die zusätzliche Vorteilung ja nur bei Bedarf erfolgt, bleibt der Fehler der Baudzeit deutlich unter 1\% ,
weil die Zeit für eine Basisverzögerung auf einen Prozessor-Takt genau eingehalten wird.
Die Basisschleife hat mindestens 127 Durchläufe mit etwa 381 Takten. Die doppelte Verzögerungszeit
macht auch noch keinen Fehler wegen des ,,NOP'' Ausgleichs. Somit bleibt der Fehler unter 1:762,
also 0.13\%. Probleme mit der Einhaltung der Baudrate bestehen also eher für hohe Baudraten,
weil die Übertragungszeit für ein Bit nicht zum vorgegebenen Zeitraster durch den CPU-Takt paßt.
Das gleiche Problem hat dann aber auch die Hardware UART-Schnittstelle.
Ein Beispiel erläutert das Problem.
Wenn man mit \(8 MHz\) CPU-Taktrate eine Baudrate von 230400 erzeugen möchte, 
kann man entweder 34 Takte mit einer Taktzeit von \(4.25\mu s\) oder 35 Takte
mit einer Baud-Zeit von \(4.375\mu s\) verwenden. Im ersten Fall ist die Baud-Zeit
um \(2.08\%\) zu kurz, im zweiten Fall ist die Baud-Zeit um \(0.8\%\) zu lang.


\subsection{Benutzung von mehr als einer seriellen Schnittstelle}

Die Assembler Datei soft\_uart.S ist dafür ausgelegt,
von einer anderen Datei eingefügt (\#include) zu werden, welche ein
normales Assembler-Programm für die AVR-Familie beinhaltet.
Für die optiboot Applikation wird das von der Datei optiboot.S gemacht.
Die eingefügte Datei soft\_uart.S benutzt viele Anweisungen für den GNU C-Processor
und fügt eine weitere Datei uart\_delay.S ein, um eine Verzögerungsschleife
für die gewünschte Baud-Rate zu generieren.
Weil dieses Verfahren für uart\_delay.S mit anderen Parametern mehrfach wiederholt werden kann,
kann man bis zu 4 verschiedene Verzögerungsschleifen erzeugen lassen.
Diese Vorgehensweise nutzt die Datei soft\_uart.S für die Erzeugung der
getch und putch Funktion. Für beide Funktionen wird die Datei uart\_delay.S
eingefügt. Aber für den zweiten \#include wird meistens keine neue Verzögerungsschleife
produziert, weil die Parameter beim zweiten Aufruf gleich sind.
Nur bei verschiedenen Parametern wird eine neue Verzögerungsschleife generiert.
Bitte beachten Sie, daß die Aufrufe der Verzögerungsschleifen mit C-Preprozessor Makro Namen
versehen sind. Diese Makro Namen DOUBLE\_DELAY\_CALL und SINGLE\_DELAY\_CALL
werden durch die richtigen Funktionsnamen ersetzt, wenn die \#include Anweisung
vor der Befehlsfolge  für die serielle Eingabe- oder Ausgabe-Funktion steht.

Drei Konstanten müssen vor jeder Einfügung von uart\_delay.S gesetzt sein,
F\_CPU, BAUD\_RATE und LOOP\_TICS. Die Konstante LOOP\_TICS muß auf die Anzahl
der Takte gesetzt sein, die von einer seriellen Bit-Ausgabe in der Schleife
gebraucht wird (normalerweise 9 Takte).
Für jede erzeugte Verzögerungsfunktion wird die Anzahl der Verzögerungstakte
in einer von vier verschiedenen Konstanten-Namen des C-Prozessors gespeichert,
BIT\_CLOCKS\_0, BIT\_CLOCKS\_1, BIT\_CLOCKS\_2 und  BIT\_CLOCKS\_3.
Bevor eine neue Verzögerungsschleife erzeugt wird, prüft der C-Preprozessor,
ob eine schon erzeugte Schleife zu den geforderten Parametern paßt.
Weil die Datei soft\_uart.S auch mit \#include eingefügt werden muß,
kann man diesen include auch mit anderen Parametern für eine andere
serielle Schnittstelle wiederholen. Aber man muß eine weitere Konstante
vorbesetzen, um die Namen der erzeugten Funktionen zu unterscheiden.
Wenn Sie die Konstante SOFT\_UART\_NUMBER vor dem \#include
auf 1 setzen (\#define SOFT\_UART\_NUMBER 1), wird die Funktion für die
serielle Eingabe getch\_1 und die Funktion für die serielle Ausgabe putch\_1 heißen.
Wenn man die Konstante NO\_SOFT\_UART\_TX vor dem \#include gesetzt hat,
wird keine serielle Ausgabefunktion generiert.
Gleiches gilt auch für die serielle Eingabe, wenn die Konstante NO\_SOFT\_UART\_RX
vor dem \#include gesetzt ist.

\subsection{Serielle Eingabe und Ausgabe über nur einen AVR Pin}

Manchmal ist es sinnvoll, die serielle Datenkommunikation nur über einen Pin zu betreiben,
um einen der wenigen IO-Pins bei kleinen AVRs freizuschalten. 
Mit einer speziellen Schaltungstechnik kann erreicht werden, daß in den Ausgabe-Pausen
der seriellen Ausgabe ein Einlesen von Daten möglich ist.
Bei der hier bei optiboot gewählten Software-Lösung ist ohnehin nur ein Halb-Duplex Betrieb
möglich. Es kann also zu einer Zeit nur entweder Daten gesendet oder Daten empfangen werden.
Normalerweise wird der Ausgabepin mit der TX-Funktion in den Sendepausen auf High Pegel
geschaltet, was ein Einlesen von Daten auf dem gleichen Pin verhindert.
Wenn aber der TX Ausgabepin statt auf den High Pegel in den Sendepausen auf den Eingabemodus
zurückgeschaltet wird, kann ein externer Pull-Up Widerstand den erforderlichen High Pegel
erzeugen.
Im Gegensatz zum festen High Pegel kann jetzt aber ein extern angeschlossenes TX-Signal
den Pegel für die serielle Einlesefunktion auf Low Pegel ziehen.
Ein serieller Widerstand in der Verbindung von dem gemeinsamen TX/RX Pin
des AVR mit dem TX Ausgang kann die Funktion des Pull-Up Widerstandes übernehmen,
da der Ruhezustand dieser Schnittstelle auf High Pegel liegt.
Außerdem sorgt dieser serielle Widerstand für eine Strombegrenzung,
falls doch einmal beide TX Schnittstellen gleichzeitig senden.
Damit die TX-Ausgabe des AVR von der externen seriellen Schnittstelle gelesen werden kann,
muß der RX-Eingang direkt mit dem gemeinsamen TX/RX verbunden werden.
Die Abbildung~\ref{fig:onewire-simple} soll die einfachste Verbindung veranschaulichen.

\begin{figure}[H]
\centering
\scalebox{1.0}{\includegraphics[]{../FIG/OneWire_simple.eps}}
\caption{Mögliche serielle Verbindung zum AVR mit einem Pin}
\label{fig:onewire-simple}
\end{figure}

Das Problem besteht nun darin, daß die meistens full-duplex fähige externe serielle Schnittstelle
die eigene Ausgabe zurückliest.
Darauf ist das Kommunikationsprogramm auf der externen Seite im allgemeinen nicht vorbereitet.
Es gibt nun die Möglichkeit, das Programm auf der externen Seite entsprechend anzupassen.
Ich halte das für keine gute Idee, da die angepasste Version dann entweder keine Wartung
mehr erhält oder es müßte die Änderung für neue Versionen ständig wiederholt werden.
Aus diesem Grund bevorzuge ich eine Hardware-Lösung.
Eine elektronische Schaltung, die zwischen die beiden Endpunkte der seriellen Schnittstelle
geschaltet wird, muß unterscheiden, ob die Daten von der externen Schnittstelle oder
von der AVR Seite gesendet werden.
Ein entsprechender Schaltungsvorschlag zeigt die Abbildung~\ref{fig:onewire}.

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire.eps}}
\caption{Schaltung zur Unterdrückung des Echos}
\label{fig:onewire}
\end{figure}

Mit den zwei ersten NAND Gattern des HCF4093 wird ein Flip-Flop gebildet,
welches von den zwei weiteren NAND Gattern dieses Bausteins
in den einen oder anderen Zustand geschaltet wird. Die Schaltsignale werden von
einer Kette von invertierenden Buffern mit Schmitt-Trigger Eingängen (HC7414) abgegriffen.
An einer Stelle ist ein zusätzliches C-R Glied (\(120 pF\) und \(3.3 k\Omega\) erforderlich,
um ein Schalten bei einer unerwünschten Flanke zu verhindern.
Umgeschaltet wird jeweils mit einer 1-0 Flanke der beiden Sendeseiten.
Erforderlich ist diese Umschaltung nur bei der Flanke des Startbits.
Aber ein zusätzliches Schalten durch Datenbits schadet nicht, wenn das Flip-Flop schon im
richtigen Zustand ist. Wenn die externe Schnittstelle sendet, wird der Empfang der
Daten über den externen Empfänger verhindert. Das externe RX-Signal bleibt auf High Pegel.
Mit dieser Zusatzschaltung ist keine Software-Anpassung notwendig. Für den
Bootloader kann zum Beispiel das avrdude Programm benutzt werden.
Die Schaltung ist weitgehend unabhängig von der benutzen Baudrate.
Lediglich bei sehr hohen Baud-Raten erwarte ich Probleme. Bei 115200 Baud läuft die Schaltung
aber einwandfrei. Sehr viel höhere Baudraten sind bei der Softwarelösung sowieso
oft nicht möglich.

\section{Einige Beispiele für die Erzeugung eines optiboot Bootloaders}

Das erste Beispiel ist die Bildung eines Bootloaders für den beliebten ATmega328P:

\begin{verbatim}
optiboot $ make atmega328p
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret \
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 \
 -DLED=p -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0
pin_defs.h:183:4: warning: #warning "LED bit is set to default B5" [-Wcpp]
optiboot.S:530:6: warning: #warning BAUD_RATE error greater than 2% [-Wcpp]
---------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200, Real: 117647, UBRRL = 16, Error=2.12%
---------------------------------------------------------------------------
######################################
Boot Loader start address: 0x7E00
######################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    474	      0	      0	    474	    1da	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Wenn keine zusätzliche Option angegeben wird, wird eine Baudrate von 115200 mit einer Taktfrequenz von \(16 MHz\) gewählt.
Für die serielle Ausgabe wird die vorhandene Hardware-Schnittstelle benutzt. 
Man beachte, daß der systematische Fehler der Baudrate über 2\% mit dem Hardware UART beträgt.
Das zweite Beispiel zeigt die Erzeugung von optiboot für den gleichen Prozessor mit einer Software-Lösung
für die serielle Schnittstelle.

\begin{verbatim}
optiboot $ make atmega328p SOFT_UART=1
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret \
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3  -DSOFT_UART=1 -DSUPPORT_EEPROM=1 \
 -DLED=p -DUART_RX=p -DUART_TX=p -DF_CPU=16000000 -c -o optiboot.o optiboot.S
In file included from optiboot.S:254:0:
pin_defs.h:183:4: warning: #warning "LED bit is set to default B5" [-Wcpp]
pin_defs.h:192:4: warning: #warning use default RX PD0 for Soft UART [-Wcpp]
pin_defs.h:200:4: warning: #warning use default TX PD1 for Soft UART [-Wcpp]
---------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200, SoftUART_Real: 115107, Error=-.08%
---------------------------------------------------------------------------
######################################
Boot Loader start address: 0x7E00
######################################

16000000 Hz operation with Baudrate 115200 configured.
avr-size optiboot.elf
   text	   data	    bss	    dec	    hex	filename
    494	      0	      0	    494	    1ee	optiboot.elf
Requires 1 Boot Pages, 512 Bytes each
BOOTSZ=3
avr-objdump -h -S optiboot.elf > optiboot_atmega328p.lst
avr-objcopy -j .text -j .data -j .version --set-section-flags .version=alloc,load \
 -O ihex optiboot.elf optiboot_atmega328p.hex
\end{verbatim}

Beachten Sie bitte, daß die Software-Lösung für die serielle Schnittstelle etwas mehr flash-Speicher braucht,
aber es wird auch nur eine ,,boot page'' gebraucht. Der systematische Fehler der Baudrate ist hier deutlich kleiner
wie bei dem Hardware-UART.
Aber der Hardware-UART hat den Vorteil, daß Eingang und Ausgang gleichzeitig bearbeitet werden kann (full duplex) und 
außerdem ist die Hardware-Lösung fehlertoleranter gegenüber kurzen Störungen des Eingangssignals.
Für die serielle Schnittstelle mit Software kann jeder digitale IO-Pin als Eingang (UART\_RX) und als Ausgang (UART\_TX)
gewählt werden. In diesem Beispiel wird die Fähigkeit benutzt, automatisch die IO-Pins des Hardware-UART's zu wählen.
Die drei ,,warning'' Meldungen, die Sie über diese automatische Wahl informieren, können Sie ignorieren.
Die automatische Wahl der IO-Pins hängt vom gewählten Prozessor-Typ und von der gewählten UART Nummer ab,
wenn mehr als ein UART zur Verfügung steht.

\section{Anpassung der Taktfrequenz bei internem RC-Generator}

Die Benutzung der seriellen Schnittstelle ist nur möglich, wenn die eingestellte Baudrate
hinreichend genau eingehalten wird. Die tatsächliche Baudrate hängt unmittelbar von dem tatsächlichen
Prozessortakt und von dem berücksichtigtem Teilerverhältnis für die Takt der seriellen Ein-Ausgabe ab.
Die Hardware UART Schnittstelle teilt den Prozessortakt generell durch 8 oder durch 16 und kann
dann für den bereits vorgeteilten Takt einen weiteren einstellbaren Teiler zwischen 1:1 und 1:4096  
zur Erzeugung des Taktes für die serielle Schnittstelle benutzen. Für niedrige Baudraten kann der
Prozessortakt bei Bedarf noch um zusätzliche 2er Potenzen geteilt werden.
Wenn das Verhältnis zwischen dem Prozessortakt zu dem Baudraten-Takt ausreichend hoch ist, kann damit
die Baudrate ausreichend genau eingestellt werden. Bei der Erzeugung des Optiboot Bootloaders
wird der systematische Fehler dieser Erzeugung protokolliert.
Normalerweise sind Fehler von weniger als 2\%  als unkritisch anzusehen.
Für die Implementation der seriellen Schnittstelle mit Software (SOFT\_UART) werden meistens geringere
systematische Fehler der Baudrate erreicht. Hier liegen die Schwierigkeiten bei der fehlenden
Fehlerunterdrückung der Einlese-Funktion und bei der mangelden Fähigkeit, die Schnittstelle
,,voll duplex'' zu betreiben. Von der Ausgabe des letzten Bits bis zur Empfangsbereitschaft vergeht immer
eine gewisse Zeit. Daher ist hier bei geringeren Baudraten mit weniger Schwierigkeiten zu rechnen.

Alle diese Betrachtungen setzen aber voraus, daß der Prozessortakt selbst hinreichend genau eingehalten wird.
Bei Quarz oder Keramik-Resonator Betrieb ist das meistens ohne weitere Maßnahmen der Fall.
Anders sieht das aber bei der Benutzung des internen RC-Generators der AVR Prozessoren aus.
Hier kann die Prozessorfrequenz deutlich vom Wunschwert abweichen. Die Prozessoren sind zwar ab Werk
vorkalibriert. Dies gilt aber oft nur für eine Frequenz und für eine Temperatur und eine Betriebsspannung.
Je nach Prozessortyp ist die Frequenz des RC-Generators mehr oder weniger abhängig von Temperatur
und Betriebsspannung.

Um vorhandene Fehler der Frequenz mit dem internen RC-Generators ausgleichen zu können,
wird der Kalibrationswert des Herstellers beim Start des Prozessors in das IO-Register OSCCAL kopiert.
Der Optiboot Bootloader kann die Option OSCCAL\_CORR benutzen, um den vorhandenen Restfehler
auszugleichen. In den folgenden Unterkapiteln werde ich einige AVR-Typen exemplarisch näher
untersuchen.

\subsection{Untersuchung der RC-Generatoren des ATmega8}

Der ATmega8 kann 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, 1~MHz, 2~MHz, 4~MHz und 8~MHz.
In der Tabelle \ref{tab:mega8freq} habe ich alle 4 Frequenzeinstellungen untersucht.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -8  & 1050k &  4  & 983k  & 0  & 1004k \\
    \hline
                2M & 0xA2  & 19.2k &  -8  & 2098k &  4  & 1967k & 0  & 2008k \\
    \hline
                4M & 0xA3  & 19.2k &  -2  & 4201k & 10  & 3927k & 7  & 3999k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8231k & 13  & 7723k & 6  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega8}
  \label{tab:mega8freq}
\end{table}

Die Tabelle \ref{tab:mega8freq} zeigt, daß für den 1Mhz und 2MHz Betrieb eine Korrektur des
OSCCAL Registers nicht erforderlich ist. Dieser ATmega8 ist ab Werk für diese Frequenzen sehr gut kalibriert.
Bei 4MHz kommt man noch ohne Korrektur aus, erreicht aber bei OSCCAL\_CORR=7 die richtige
Schwingfrequenz. Bei 8MHz ist der Betrieb der seriellen Schnittstelle so gerade eben
noch möglich, sicherer läuft die serielle Schnittstelle aber mit OSCCAL\_CORR=6.

\subsection{Untersuchung der RC-Generatoren des ATmega8535}

Der ATmega8535 kann wie der ATmega8 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, 1~MHz, 2~MHz, 4~MHz und 8~MHz.
In der Tabelle \ref{tab:mega8535freq} sind die Ergebnisse bei einem Exemplar für
 alle 4 Frequenzeinstellungen festgehalten.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  3  & 982k  & 0  & 1001k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2095k &  4  & 1965k & 1  & 1998k \\
    \hline
                4M & 0xA3  & 19.2k &  -5  & 4204k &  8  & 3932k & 4  & 4012k \\
    \hline
                8M & 0xA4  & 19.2k &  -7  & 8420k &  6  & 7901k & 3  & 8003k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega8535}
  \label{tab:mega8535freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATmega328 Familie}

Bei der ATmega328 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein 1MHz Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega328freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega48P &          8M & 0xE2  & 57.6k &  -6  & 8230k &  8  & 7720k  & 0  & 8010k \\
    \hline
mega88 &          8M & 0xE2  & 57.6k &  -2  & 8250k & 10  & 7770k  & 4  & 7990k \\
    \hline
mega168 &          8M & 0xE2  & 57.6k &  -5  & 8263k &  8  & 7720k  & 1  & 7970k \\
    \hline
mega328P &          8M & 0xE2  & 57.6k &  -5  & 8250k &  9  & 7723k  & 1  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega328 Familie}
  \label{tab:mega328freq}
\end{table}

Bei allen untersuchten Prozessoren ist ein Betrieb der seriellen Schnittstelle 
auch mit dem internen RC-Oszillator möglich. Nur bei dem untersuchten ATmega88 
würde sich bei OSCCAL\_CORR=4 eine Korrektur überhaupt lohnen.

\subsection{Untersuchung der RC-Generatoren des ATmega32 / 16}

Der ATmega32 und der ATmega16 können 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, 1~MHz, 2~MHz, 4~MHz und 8~MHz.
In den Tabellen \ref{tab:mega32freq} und \ref{tab:mega16freq} habe ich alle 
4 Frequenzeinstellungen untersucht.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c || c | c || c | c || c | c |}
    \hline
        &     AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
 Typ    &     FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
m32  &       1M    & 0xA1  &  9.6k &  -13  & 1049k & -1  & 980k  & -5  & 1001k \\
m32a &             &       &       &  -7  & 1046k &  4  & 984k  & 1  & 998k \\
    \hline
m32  &       2M    & 0xA2  & 19.2k &  -12  & 2102k &  0  & 1968k & -3  & 1997k \\
m32a &             &       &       &  -7  & 2105k &  6  & 1966k & 2  & 2005k \\
    \hline
m32  &       4M    & 0xA3  & 19.2k &  -5  & 4169k & 6  & 3942k & 3  & 3993k \\
m32a &             &       &       &   2  & 4192k & 14  & 3939k & 10  & 4015k \\
    \hline
m32  &       8M    & 0xA4  & 19.2k &  -7  & 8425k &  6  & 7888k & 3  & 7983k \\
m32a &             &       &       &   2  & 8408k & 14  & 7921k & 11  & 8014k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega32}
  \label{tab:mega32freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -11  & 1047k &  1  & 982k  & -2  & 998k \\
    \hline
                2M & 0xA2  & 19.2k &  -12  & 2099k &  0  & 1971k & -3 & 1995k \\
    \hline
                4M & 0xA3  & 19.2k &  -9  & 4291k &  3  & 3932k & 0  & 4002k \\
    \hline
                8M & 0xA4  & 19.2k &  -11 & 8415k & 2  & 7857k & -2  & 8013k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega16A}
  \label{tab:mega16freq}
\end{table}

Immer wenn in der MinCorr Spalte positive Werte oder in der MaxCorr Spalte negative
Werte auftauchen, ist bei dieser Frequenz und diesem Prozessor-Exemplar der Betrieb
der seriellen Schnittstelle ohne Korrektur nicht möglich.
Wenn eine 0 in den Spalten auftaucht, ist der Betrieb der seriellen Schnittstelle
gerade eben noch möglich.

\subsection{Untersuchung des RC-Generators des ATmega163L}

Der ATmega163L besitzt nur einen 1MHz RC-Generator, der mit dem OSCCAL Register
abgestimmt werden kann. Mein Exemplar hatte keine Voreinstellung des OSCCAL Wertes.
Daher sind hier außergewöhnlich hohe Korrekturwerte erforderlich, um die Frequenz
auf etwa 1MHz einstellen zu können.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0x92  &  9.6k &  -88  & 1026k &  -62  & 964k  & -77  &  998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenz des ATmega163L}
  \label{tab:mega163freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren des ATmega64 / 128}

Der ATmega64 und der ATmega128 können 4 verschiedene Frequenzen mit dem internen RC-Generator
über die Low-Fuse einstellen, 1~MHz, 2~MHz, 4~MHz und 8~MHz.
In den Tabellen \ref{tab:mega64freq} und \ref{tab:mega128freq} habe ich alle 
4 Frequenzeinstellungen untersucht.
An dieser Stelle sei auch ein Hinweis erlaubt, das das Laden der Programmdaten über die 
ISP-Schnittstelle nicht mit den Signalen MISO und MOSI, sondern über die Signale TXD (PE1) und RXD (PE0)
erfolgt. Dies muß natürlich beim Anschluß an den Programmer berücksichtigt werden.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -4  & 1024k &  6  & 975k  & 1  & 1000k \\
    \hline
                2M & 0xA2  & 19.2k &  -4  & 2047k &  6  & 1952k & 0  & 2015k \\
    \hline
                4M & 0xA3  & 19.2k &   4  & 4070k & 10  & 3939k & 8  & 3976k \\
    \hline
                8M & 0xA4  & 57.6k &   6  & 8028k & 10  & 7847k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega64}
  \label{tab:mega64freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
             AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -9  & 1051k &  3  & 985k  & 0  &  999k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2102k &  3  & 1971k & 0  & 2000k \\
    \hline
                4M & 0xA3  & 19.2k &  -3  & 4209k &  9  & 3960k & 6  & 4006k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8225k & 13  & 7723k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die RC-Frequenzen des ATmega128}
  \label{tab:mega128freq}
\end{table}

Die Tabellen zeigen, daß für den 1Mhz und 2MHz Betrieb eine Korrektur des
OSCCAL Registers nicht erforderlich ist. Bei 4MHz und 8MHz Betrieb kann die serielle Schnittstelle
aber beim untersuchten ATmega64 nicht ohne Korrektur betrieben werden.
Ohne Korrektur wäre die 4MHz Frequenz um etwa 4\% zu hoch und die 8MHz Frequenz um etwa 4.3\% zu hoch.
In der Dokumentation von Atmel wird übrigens abgegeben, daß der
RC-Generator des ATmega64 und ATmega128 bei 1MHz abgeglichen wird.
Es sei noch einmal darauf hingewiesen, daß es sich bei den Tabellendaten um die Untersuchung eines einzelnen 
Exemplars des ATmega handelt. Außerhalb der angegebenen Min- bzw. Max-Werte der OSCCAL Korrekturen war
ein Betrieb der seriellen Schnittstelle bei der angegebenen Baud-Rate nicht möglich.

\subsection{Untersuchung der RC-Generatoren der ATmega644 Familie}

Bei der ATmega644 Familie kann  eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Daneben kann
auch noch ein 128kHz Gererator als Takt gewählt werden, der sonst den Watchdog-Timer versorgt.
Die gwählte Frequenz kann aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden,
so daß auch ein 1MHz Betrieb eingestellt werden kann.
Die Tabelle~\ref{tab:mega644freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1284p &          8M & 0xC2  & 19.2k & -8  & 8416k & 7  & 7882k  & 4  & 7989k \\
    \hline
mega644p &          8M & 0xC2  & 19.2k &  -12 & 8416k & 3  & 7871k  & -1  & 8009k \\
    \hline
mega324p &          8M & 0xC2  & 19.2k &  -12 & 8398k & 3  & 7885k  & 0  & 7976k \\
    \hline
mega164p &          8M & 0xC2  & 19.2k &  -5  & 8401k & 4  & 7888k  & 2  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega644 Familie}
  \label{tab:mega644freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATmega645 Familie}

Bei der ATmega645 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein 1MHz Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega645freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega165p &         8M & 0xE2  & 57.6k & -6  & 8235k &  7  & 7718k  & -1  & 8015k \\
    \hline
mega645 &          8M & 0xE2  & 57.6k &  0  & 8253k & 12  & 7726k  & 5  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega645 Familie}
  \label{tab:mega645freq}
\end{table}

Beim ATmega645 ist der Betrieb der seriellen Schnittstelle ohne OSCCAL Korrektur gerade noch möglich.
Sicherer ist aber der Betrieb mit OSCCAL\_CORR=5, da dann die 8MHz besser eingehalten werden. 

\subsection{Untersuchung der RC-Generatoren der ATmega649 Familie}

Bei der ATmega649 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gewählt werden. Die Frequenz kann
aber mit einem Fuse-Bit mit Faktor 8 vorgeteilt werden, so daß auch ein 1MHz Betrieb eingestellt
werden kann. Die Tabelle~\ref{tab:mega649freq} zeigt die Resultate der untersuchten Prozessoren.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega169 &          8M & 0xE2  & 57.6k &  -9  & 8250k & 2  & 7864k  & -2  & 8010k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATmega649 Familie}
  \label{tab:mega649freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATtiny84 Familie}

Bei der ATtiny84 Familie kann außer dem 8MHz RC-Oszillator auch noch der 
128kHz Takt der Watchdog-Schaltung benutzt werden.
Der 128kHz Takt kann nicht kalibriert werden. Wenn man diesen Takt benutzen möchte,
kann man die erzeugte Baudrate nur über den vorgegebenen Wert korrigieren.
Bei einem ATtiny24a habe ich die erzeugte Baudrate kontrolliert. Statt der
eingestellten 2400 Baud habe ich nur 2170 Baud gemessen. Das ergibt einen Frequenzfehler
von etwa 9.6\% und damit deutlich zu viel, um ohne Korrektur benutzt werden zu können.
Bei eingestellten 2640 Baud funktionierte der Download mit 2400 Baud.
Die gemessene Taktrate betrug dann nur 115.2kHz anstelle der 128kHz.
Die Tabelle~\ref{tab:tiny84freq} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den 8MHz Betrieb dar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny84 &          8M & 0xE2  & 19.2k &  -6  & 8453k & 14  & 7673k  & 5  & 8019k \\
    \hline
attiny44a &         8M & 0xE2  & 19.2k &  -16  & 8367k & 3  & 7673k  & 7  & 7984k \\
    \hline
attiny24a &         8M & 0xE2  & 19.2k &  -4  & 8388k & 11  & 7685k  & 4  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny84 Familie}
  \label{tab:tiny84freq}
\end{table}

\subsection{Untersuchung der RC-Generatoren der ATtiny85 Familie}

Bei der ATtiny84 Familie kann außer dem 8MHz RC-Oszillator auch noch der 
ein 6.4MHz RC-Oszillator und der 128kHz Takt der Watchdog-Schaltung benutzt werden.
Der 6.4MHz RC-Oszillator wird aber immer mit einem Frequenzteiler auf 1.6MHz
heruntergeteilt.
Der 128kHz Takt kann nicht kalibriert werden. Wenn man diesen Takt benutzen möchte,
kann man die erzeugte Baudrate nur über den vorgegebenen Wert korrigieren.
Die erste Tabelle~\ref{tab:tiny85freq8} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den 8MHz Betrieb dar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &          8M & 0xE2  & 38.4k &  -4  & 8370k &  9  & 7714k  & 3  & 8012k \\
    \hline
attiny45  &         8M & 0xE2  & 38.4k &  -4  & 8400k & 9  & 7706k  & 3  & 8030k \\
    \hline
attiny25  &         8M & 0xE2  & 38.4k &  -9  & 8424k & 46  & 7724k  & 40  & 8034k \\
attiny25  &         8M & 0xE2  & 38.4k &  -12  & 8399k & 7  & 7680k  & -2  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei 8MHz}
  \label{tab:tiny85freq8}
\end{table}

Die Einstellwerte bei einem ATtiny25 sehen merkwürdig aus, aber bei der Korrektur 3 hat
der OSCCAL Wert die Zahl 128 unterschritten und ist damit in einem anderen Stellbereich.
Erst bei einem Korrekturwert von etwa 34 wurde dann wieder eine Frequenz von 8364kHz
erreicht, bei der die serielle Schnittstelle wieder betrieben werden kann. Eine ähnliche
Frequenz wurde im anderen Stellbereich beim Korrekturwert -6 erreicht.
Die nächste Tabelle~\ref{tab:tiny85freq1} stellt für die untersuchten Exemplare die möglichen
OSCCAL Änderungen für den 1.6MHz Betrieb dar. Der RC-Generator läuft dabei bei 6.4MHz,
diese Frequenz wird aber immer durch Faktor 4 geteilt. 

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xD3  & 9.6k &  -7  & 1684k &  9  & 1547k  & 2  & 1603k \\
    \hline
attiny45  &        1.6M & 0xD3  & 9.6k &  -5  & 1684k & 11  & 1559k  & 4  & 1603k \\
    \hline
attiny25  &        1.6M & 0xD3  & 9.6k &  -7   & 1689k & 10 & 1543k  & 3  & 1602k \\
attiny25  &        1.6M & 0xD3  & 9.6k &  -10  & 1680k & 3  & 1550k  & -3  & 1609k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei 1.6MHz}
  \label{tab:tiny85freq1}
\end{table}

Bei dem Betrieb mit 1.6MHz hat sich die Besonderheit mit der OSCCAL Korrektur-Einstellung
nicht gezeigt. Alle untersuchten Exemplare würden auch ohne Korrektur der Frequenz
mit der seriellen Schnittstelle arbeiten können.
Die ATtiny84 Prozessor Familie kann den Prozessor auch mit einem PLL-Oszillator betreiben,
der vom 8MHz RC-Oszillator kontrolliert wird. Der PLL-Oszillator kann entweder 64MHz oder
32MHz erzeugen, die normalerweise für den T1 Zähler benutzt werden können.
Wenn der PLL-Takt als Prozessor-Takt verwendet werden soll, kann der PLL-Oszillator nur
bei 64MHz arbeiten und wird immer durch Faktor 4 geteilt. Somit ergeben sich 16MHz 
für den Prozessortakt. Die Tabelle~\ref{tab:tiny85freq16} zeigt die gemessenen
Resultate. Erwartungsgemäß weichen diese Ergebnisse nicht wesentlich von den 8MHz Ergebnissen
ab.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xF1  & 38.4k &  -4  & 16.87M &  10  & 15.41M  & 4  & 16.02M \\
    \hline
attiny45  &        1.6M & 0xF1  & 38.4k &  -4  & 16.87M & 10  & 15.41M  & 4  & 15.95M \\
    \hline
attiny25  &        1.6M & 0xF1  & 38.4k &  -9   & 16.91M & 47 & 15.38M  & 41  & 16.03M \\
attiny25  &        1.6M & 0xF1  & 38.4k &  -11  & 16.82M & 7  & 15.43M  & -2  & 16.07M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny85 Familie bei 16MHz}
  \label{tab:tiny85freq16}
\end{table}

\subsection{Untersuchung des RC-Generators der ATtiny88 Familie}

Die ATtiny88 Familie kann außer einem 8MHz internem RC-Generator nur noch einen
nicht kalibrierbaren 128kHz Generator oder einen externen Takt als Taktgeber für
den Prozessor wählen. Ein Frequenzteiler mit Faktor 8 ist für den Prozessortakt
bei der LFUSE auch einstellbar. In der Tabelle~\ref{tab:tiny88freq} sind die Ergebnisse
für die Kalibration des internen 8MHz Generators bei zwei Exemplaren der Familie dargestellt. 

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ  &       AVR\_ & LFUSE & Baud- & Min- & Min- & Max- & Max- & Best- & Best-  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny88 &          8M & 0xE2  & 38.4k &  -4  & 8397k & 15  & 7682k  & 6  & 8013k \\
    \hline
attiny48 &         8M & 0xE2  & 38.4k &  -5  & 8385k & 12  & 7739k  & 5  & 7995k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Mögliche OSCCAL\_CORR Einstellungen für die ATtiny88 Familie}
  \label{tab:tiny88freq}
\end{table}

Bei beiden Exemplaren läuft die serielle Schnittstelle ohne Frequenz-Korrektur. 
Die Takt-Frequenz wird aber bei einer Korrektur von 5 (6) besser eingehalten.
